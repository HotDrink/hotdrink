#+TITLE: Basic HotDrink Usage
#+LANGUAGE:  en
#+OPTIONS: H:2 author:nil creator:nil
#+HTML_HEAD_EXTRA: <script type="text/javascript" src="hotdrink.min.js"></script>
#+HTML_HEAD_EXTRA: <link rel="stylesheet" type="text/css" href="style.css"/>

* Creating a constraint system

The most fundamental part of a GUI written with HotDrink is the constraint
system which represents data dependencies in your GUI.  This first example
covers a lot of ground, including how to create a constraint system, how you
can directly interact with it by getting and setting variables, and how the
constraint system is updated.  The goal is to give you an exact understanding
of what the constraint system does for you and how you may interact with it.

We assume here that you have read the document [[file:intro.org][Introduction to HotDrink]] and
are therefore familiar with the basic concept of a constraint system.

** The example

/View/

#+BEGIN_SRC html -n -r :exports code :tangle tangle/whatever.html :padline no
<table>
  <style type="text/css" scoped>
    td { padding-right: 1ex; }
    th { padding-right: 1ex; text-align: left; font-weight: bold; }
  </style>
  <tr>
    <th>List:</th>
    <td><span id="listSpan1"></span></td>
    <td><input type="button" value="Set" onclick="setList1()"/></td>
  </tr>
  <tr>
    <th>Filter:</th>
    <td><span id="filterSpan1"></span></td>
    <td><input type="button" value="Set" onclick="setFilter1()"/></td>
  </tr>
</table>
<br/>
<input type="button" value="Get Result" onclick="getResult1()"/>
#+END_SRC

/View-Model/

#+BEGIN_SRC js -n -r :exports code :tangle tangle/whatever.js :padline no
// Define the model
var model = new hd.ModelBuilder() (ref:builder)
    .variable( 'list', 'ebip, snad, ebna, naip, sneb, ipeb' ) (ref:varlist)
    .variable( 'filter', 'na' ) (ref:varfilter)
    .variable( 'result' ) (ref:varresult)

    .constraint( 'list, filter, result' ) (ref:con)
    .method( 'list, filter -> result', function( list, filter ) { (ref:mth1)
      var words = list.trim().split( /\s*,\s*/ );
      var filteredWords = words.filter( function( word ) {
        return word.indexOf( filter ) > -1;
      } );
      return filteredWords.join( ', ' );
    } )

    .end(); (ref:end)

// Create the constraint system
var system = new hd.ConstraintSystem();
system.addComponent( model );
system.update(); (ref:update1)
#+END_SRC

/Binding/

#+BEGIN_SRC js -n -r :exports code :tangle tangle/whatever.js :padline no
window.addEventListener( 'load', function() {
  setSpan( 'listSpan1', model.list.get() );
  setSpan( 'filterSpan1', model.filter.get() );
} )

function setSpan( id, value ) {
  var span = document.getElementById( id );
  while (span.lastChild) { span.removeChild( span.lastChild ); }
  span.appendChild( document.createTextNode( value ) );
}

setList1 = function setList1() {
  var list = window.prompt( 'List:', model.list.get() );
  if (list !== null) {
    model.list.set( list );
    system.update(); (ref:update2)
    setSpan( 'listSpan1', list );
  }
}

setFilter1 = function setFilter1() {
  var filter = window.prompt( 'Filter:', model.filter.get() );
  if (filter !== null) {
    model.filter.set( filter );
    system.update(); (ref:update3)
    setSpan( 'filterSpan1', filter );
  }
}

getResult1 = function getResult1() {
  alert( 'Result: ' + model.result.get() );
}

#+END_SRC

/Result/

#+HTML: <div class="results">
#+INCLUDE: tangle/whatever.html html
#+HTML: </div>
#+HTML: <script type="text/javascript">
#+HTML: (function() {
#+INCLUDE: tangle/whatever.js html
#+HTML: })();
#+HTML: </script>

/Notes/

#+HTML: <div class="notes">
This example shows a single constraint of three variables: /list/, /filter/,
and /result/.  Each variable holds a string.  The value of /list/ is a
comma-delimited list of words.  The value of /filter/ is any string.  The
value of /result/ is the comma-delimited list of just those words in /list/
which contain the string in /filter/.

Note that this example deliberately avoids using any of HotDrink's binding
code so that all interactions with the constraint system will be explicit.
#+HTML: </div>


** Working with the model builder

Recall from [[file:intro.org][the introduction]] that there are two steps to creating a
constraint system.  The first is to create the /model/ --- that is, the
variables and constraints that make up the constraint system.  The second is
to create a /constraint system/ object and add the model to it.  The
constraint system object is responsible for enforcing the constraints found in
the model.

We create a model using a factory object called ~ModelBuilder~.  This object
has member functions for creating the variables, constraints, and methods that
compose the object.  The general strategy for constructing a model is: (1.)
create a new builder object, (2.) use the builder member functions to
construct the model, (3.) call the ~end~ builder member function to retrieve
the completed model.  The code below illustrates how this might be done.

#+BEGIN_SRC js
// Create new builder object
var builder = new hd.ModelBuilder();

// Use methods to construct the model
builder.variable( ... );
builder.constraint( ... );
builder.method( ... );
...and so on...

// Retrieve the completed model
var model = builder.end();
#+END_SRC

However, most builder member functions return the same builder object with
which they were invoked.  This allows a succinct programming style known as
\ldquo{}chaining\rdquo in which the return value of one member function is used to
immediately invoke the next member function.  You can see this style in the
view-model of the example.  [[(builder)][Line (builder)]] creates a new
~ModelBuilder~ object.  Rather than storing this builder in a variable, we
simply begin invoking member functions on it.  [[(varlist)][Line (varlist)]]
invokes the ~variable~ member function, which returns the anonymous builder.
This return value is used by [[(varfilter)][line (varfilter)]] to invoke
~variable~ again, which returns the builder again, and so on.  This continues
until [[(end)][line (end)]], where the ~end~ member function is invoked on the
still-anonymous builder to return the model that was constructed.  It is this
model that is assigned to the ~model~ variable on [[(builder)][line
(builder)]].

Generally, creating a model involves the following steps.

*** Creating variables

Just as in a programming language, values in HotDrink are stored in variables.
(Note, however, that HotDrink variables are /not/ the same as JavaScript
variables --- HotDrink variables are actually JavaScript objects.)  Variables
are created with the model builder using the ~variable~ member function and
then stored in the model.  To create a variable you must specify a name; you
may optionally specify an initial value.  As with JavaScript variables,
uninitialized variables are given the value ~undefined~.  For example, [[(varlist)][line
(varlist)]] of the view-model creates a variable named ~list~ which is
initialized with a list of words, and [[(varresult)][line (varresult)]] creates a variable
named ~result~ which is uninitialized.

As mentioned previously, the return value of the ~variable~ function is the
builder object itself in order to facilitate chaining.

Builder member functions such as ~variable~ are used frequently when declaring
a property model.  To make them easier to use, the model builder provides
abbreviated names for many of them.  For example, you may refer to the
~variable~ member function simply as ~v~.  This is perhaps slightly less
readable, but much easier to type; we will use the abbreviated name ~v~ in the
remainder of the examples.

*** Creating constraints

Recall from [[file:intro.org][the introduction]] that a constraint is simply
something that should always be true concerning some of your variables ---
i.e., a /relation/ over the variables.  In the example above, the relation is
that ~result~ is just those words in ~list~ which contain the string in
~filter~.

To define a constraint, you must specify the variables involved.  To make this
simple, the ~constraint~ member function of the model builder takes a string
containing all of the variables' names in a comma delimited list.  In
[[(con)][line (con)]] of the view-model we define a constraint for the
variables ~list~, ~filter~, and ~result~.

The return value of the ~constraint~ member function is the builder. The
~constraint~ member function may be abbreviated as ~c~; we will use this
abbreviation in the remainder of the examples.

*** Creating methods

Notice that, when you create a constraint, you do /not/ tell HotDrink what
relation the constraint represents.  Instead, you define a constraint by
providing /constraint satisfaction methods/, or just /methods/ for short.  A
method is a function whose parameters are /some/ variables of the constraint,
and which returns new values for /other/ variables of the constraint.  The
purpose of a method is to provide new values for its output variables that
will satisfy the constraint.

The method creation function of the model builder, named ~method~, takes a
signature and a function.  The signature is a string defining which variables
are inputs and which are outputs; it has the form "/inputs/ ~->~ /outputs/",
where both /inputs/ and /outputs/ are comma-delimited lists of variables.  For
this example we provide only a single method, declared on [[(mth1)][line
(mth1)]].  This method takes ~list~ and ~filter~ and uses them to calculate
~result~.  You can have more than one method per constraint; we'll discuss
this further in later examples.

Note that in this example we provide an anonymous function as our method, but
this is not a requirement; methods can be named functions defined elsewhere.
Also note that it is not a requirement for function parameter names to match
the variables which should be passed to them; in fact, HotDrink has no way of
knowing what you named your parameters.  HotDrink will use the signature you
provided to decide what variables to pass to the function.

Whenever you call ~method~, the builder assumes you are adding a method to the
most recently defined constraint.  As with the other builder member functions,
the return value of ~method~ is the builder to facilitate chaining, and it may
be abbreviated as ~m~; we will use this abbreviation in the remainder of the
examples.

*** Declaring the end

You begin defining a new constraint using the ~constraint~ builder member
function; you continue to add methods to it using ~method~.  However, the
constraint will not actually be completed until you indicate that all methods
belonging to the constraint have been created.  One way to do this is by
calling the ~endConstraint~ builder member function.  After you call this
function, the constraint is created and no further methods may be added to it.

However, most builder member functions (such as ~variable~, ~constraint~,
~end~, etc.) check to see if the builder has an unfinished constraint and, if
so, call ~endConstraint~ for you.  Thus, most of the time there is no need to
call ~endConstraint~ explicitly; it is only when you're doing something
unusual with the builder must you be aware of it.  Just remember, your
constraint has not been created until you call ~endConstraint~ or it is called
for you.

The ~endConstraint~ member function returns the builder object.  There is no
abbreviation for ~endConstraint~.

Similarly, to declare that you are done defining your model, you may call the
~end~ builder member function.  This function finalizes the definition of your
model.  Unlike other builder member functions, ~end~ returns the completed
model instead of returning the builder.  There is no abbreviation for ~end~.

** Interacting with variables

Variables can be accessed via the model; for example, if your model is held in
a variable named ~model~, then the variable ~list~ is accessed as
~model.list~.  The value of variables can be retrieved using the variable's
~get~ member function and modified using the variable's ~set~ member function.
If a variable is registered with a constraint system (i.e., the variable is in
a model that has been added to the constraint system), then changes to the
variable's value will be noticed by the constraint system.

In the example above, we use the ~get~ method to initialize the prompt when
setting ~list~ or ~filter~, and we also use ~get~ to report the value of
~result~.  We use ~set~ to update ~list~ or ~filter~ after the user has been
prompted for a value.  The value of ~result~ is never set explicitly.
Instead, it is updated by the constraint system whenever ~list~ or ~filter~ is
modified.

** Updating the constraint system

To /update/ the constraint system means to respond to changes that have been
made by enforcing any constraints which may no longer be satisfied.  There are
two types of changes which require a constraint system update: adding new
constraints to the system, and setting the value of a variable.  The
constraint system notices when these events occur, and remembers the changes.
However, the constraint system does not actually update until its ~update~
member function is called.  This allows you to package several changes into a
single update.  Notice where we call ~update~ in the example above.  We call
it on [[(update1)][line (update1)]] after adding our model to the constraint
system, and we call it on [[(update2)][line (update2)]] and [[(update3)][line
(update3)]] after setting variables.

If you would prefer, you can have the system automatically update after
changes.  You may set the system to immediately update after every change, or
to /schedule/ an update after every change --- meaning that it will set an
immediate timer event (using ~window.setTimeout~) that will cause the system
to update.  HotDrink will only schedule one update at a time; if it goes to
schedule an update and finds that one is already scheduled, it will /not/
schedule a second one.

The update policies of the system is controlled by two member variables:
~updateOnModelChange~ and ~updateOnVariableChange~.  These are enumerated
types which may be set to one of ~hd.Update.None~, ~hd.Update.Immediate~, or
~hd.Update.Scheduled~, as shown below.

#+BEGIN_SRC js
var system = new hd.ConstraintSystem();

// Policy for when constraints are added to system
system.updateOnModelChange = hd.Update.None;          // do not automatically update
system.updateOnModelChange = hd.Update.Immediate;     // update immediately
system.updateOnModelChange = hd.Update.Scheduled;     // schedule an update

// Policy for when variables are modified
system.updateOnVariableChange = hd.Update.None;       // do not automatically update
system.updateOnVariableChange = hd.Update.Immediate;  // update immediately
system.updateOnVariableChange = hd.Update.Scheduled;  // schedule an update
#+END_SRC

The default for both policies is ~hd.Updated.Scheduled~.  This policy is
convenient in that it does not require explicit calls to ~update~, but it
still allows multiple changes to be grouped together under a single update.
The potential downside is that you loose precise control of when updates
occur.  If this is a concern, then we recommend an alternate update policy.

Thus, in the example above, we could remove all calls to ~system.update~ with
no visible effect --- the constraint system will automatically schedule an
update after every change.  In future examples we will omit calls to
~system.update~.

* Reacting to variable changes

The previous example required clicking a button every time we wanted to see
the results.  However, there is a way we can register to be notified every
time the value of a variable changes.  Using this notification, we can show
variable updates as soon as they are available.

** The example

/View/

#+BEGIN_SRC html -n -r :exports code :tangle tangle/observer.html :padline no
<table>
  <style type="text/css" scoped>
    td { padding-right: 1ex; }
    th { padding-right: 1ex; text-align: left; font-weight: bold; }
  </style>
  <tr>
    <th>List:</th>
    <td><span id="listSpan2"></span></td>
    <td><input type="button" value="Set" onclick="setList2()"/></td>
  </tr>
  <tr>
    <th>Filter:</th>
    <td><span id="filterSpan2"></span></td>
    <td><input type="button" value="Set" onclick="setFilter2()"/></td>
  </tr>
  <tr>
    <th>Result:</th>
    <td><span id="resultSpan2"></span></td>
  </tr>
</table>
#+END_SRC

/View-Model/

#+BEGIN_SRC js -n -r :exports code :tangle tangle/observer.js :padline no
// Define the model
var model = new hd.ModelBuilder()
    .v( 'list', 'ebip, snad, ebna, naip, sneb, ipeb' ) (ref:varlist)
    .v( 'filter', 'na' )
    .v( 'result' ) (ref:varresult)

    .c( 'list, filter, result' ) (ref:con)
    .m( 'list, filter -> result', function( list, filter ) {
      var words = list.trim().split( /\s*,\s*/ );
      var filteredWords = words.filter( function( word ) {
        return word.indexOf( filter ) > -1;
      } );
      return filteredWords.join( ', ' );
    } )

    .end();

// Create the constraint system
var system = new hd.ConstraintSystem();
system.addComponent( model );
#+END_SRC

/Binding/

#+BEGIN_SRC js -n -r :exports code :tangle tangle/observer.js :padline no
window.addEventListener( 'load', function() {
  model.list.addObserverInit( {
    onNext: function( v ) { setSpan( 'listSpan2', v ) },
    onError: function( e ) { },
    onCompleted: function() { }
  } )

  model.filter.addObserverInit( {
    onNext: function( v ) { setSpan( 'filterSpan2', v ) },
    onError: function( e ) { },
    onCompleted: function() { }
  } )

  model.result.addObserverInit( {
    onNext: function( v ) { setSpan( 'resultSpan2', v ) },
    onError: function( e ) { },
    onCompleted: function() { }
  } )
} )

function setSpan( id, value ) {
  var span = document.getElementById( id );
  while (span.lastChild) { span.removeChild( span.lastChild ); }
  span.appendChild( document.createTextNode( value ) );
}

setList2 = function setList2() {
  var list = window.prompt( 'List:', model.list.get() );
  if (list !== null) {
    model.list.set( list );
    setSpan( 'listSpan2', list );
  }
}

setFilter2 = function setFilter2() {
  var filter = window.prompt( 'Filter:', model.filter.get() );
  if (filter !== null) {
    model.filter.set( filter );
    setSpan( 'filterSpan2', filter );
  }
}
#+END_SRC

/Result/

#+HTML: <div class="results">
#+INCLUDE: tangle/observer.html html
#+HTML: </div>
#+HTML: <script type="text/javascript">
#+HTML: (function() {
#+INCLUDE: tangle/observer.js html
#+HTML: })();
#+HTML: </script>

/Notes/

#+HTML: <div class="notes">
This example uses the same constraint as the previous example.  The results
are displayed in the web page, and automatically updated every time a variable
changes.
#+HTML: </div>

** The Observer pattern

The typical approach to event-based programming is to register a single
callback function to be executed any time an event occurs.  This is sometimes
known as the /observer pattern/ --- the observer provides a function to be
called when an event occurs.  In HotDrink, however, we use a variation of the
observer pattern inspired by Microsoft's [[https://rx.codeplex.com/][reactive extensions]].  In this
pattern, an observer has three associated callbacks:  one to be called for
normal event values, one for erroneous event values, and one without a value
indicating that no more events will occur.  Thus, in HotDrink, an /observer/
is any object which has the following three properties:

- ~onNext( value )~ :: function called on normal event; takes value associated
     with the event

- ~onError( error )~ :: function called when error occurs; takes value
     associated with the error

- ~onCompleted()~ :: function called when no more events can occur


* Automating variable updates

** The example

/View/

#+BEGIN_SRC html -n -r :exports code :tangle tangle/observable.html :padline no
<table>
  <style type="text/css" scoped>
    th { padding-right: 1ex; text-align: left; font-weight: bold; }
    input.long { width: 100ex; }
  </style>
  <tr>
    <th>List:</th>
    <td><input type="text" id="listEdit3" class="long"/></td>
  </tr>
  <tr>
    <th>Filter:</th>
    <td><input type="text" id="filterEdit3" class="long"/></td>
  </tr>
  <tr>
    <th>Result:</th>
    <td><span id="resultSpan3"></span></td>
  </tr>
</table>
#+END_SRC

/View-Model/

#+BEGIN_SRC js -n -r :exports code :tangle tangle/observable.js :padline no
// Define the model
var model = new hd.ModelBuilder()
    .v( 'list', 'ebip, snad, ebna, naip, sneb, ipeb' ) (ref:varlist)
    .v( 'filter', 'na' )
    .v( 'result' ) (ref:varresult)

    .c( 'list, filter, result' ) (ref:con)
    .m( 'list, filter -> result', function( list, filter ) {
      var words = list.trim().split( /\s*,\s*/ );
      var filteredWords = words.filter( function( word ) {
        return word.indexOf( filter ) > -1;
      } );
      return filteredWords.join( ', ' );
    } )

    .end();

// Create the constraint system
var system = new hd.ConstraintSystem();
system.addComponent( model );
#+END_SRC

/Binding/

#+BEGIN_SRC js -n -r :exports code :tangle tangle/observable.js :padline no
window.addEventListener( 'load', function() {
  var listObservable = new hd.BasicObservable();
  var listEdit = document.getElementById( 'listEdit3' );
  listEdit.value = model.list.get();
  listEdit.addEventListener( 'input', function() {
    listObservable.sendNext( listEdit.value );
  } );
  listObservable.addObserver( model.list );

  var filterObservable = new hd.BasicObservable();
  var filterEdit = document.getElementById( 'filterEdit3' );
  filterEdit.value = model.filter.get();
  filterEdit.addEventListener( 'input', function() {
    filterObservable.sendNext( filterEdit.value );
  } );
  filterObservable.addObserver( model.filter );

  model.result.addObserverInit( {
    onNext: function( v ) { setSpan( 'resultSpan3', v ) },
    onError: function( e ) { },
    onCompleted: function() { }
  } )
} )

function setSpan( id, value ) {
  var span = document.getElementById( id );
  while (span.lastChild) { span.removeChild( span.lastChild ); }
  span.appendChild( document.createTextNode( value ) );
}

#+END_SRC

/Result/

#+HTML: <div class="results">
#+INCLUDE: tangle/observable.html html
#+HTML: </div>
#+HTML: <script type="text/javascript">
#+HTML: (function() {
#+INCLUDE: tangle/observable.js html
#+HTML: })();
#+HTML: </script>

/Notes/

#+HTML: <div class="notes">
This example keeps the same constraint as the previous two examples.  However,
rather than manually setting a variable with a button, this example
automatically sets variables every time the corresponding edit box is changed.
#+HTML: </div>

* Translating values

** The example

/View/

#+BEGIN_SRC html -n -r :exports code :tangle tangle/translator.html :padline no
<table>
  <style type="text/css" scoped>
    th { padding-right: 1ex; text-align: left; font-weight: bold; }
  </style>
  <tr>
    <th>Income:</th>
    <td><input type="text" id="incomeEdit"/></td>
  </tr>
  <tr>
    <th>Expenses:</th>
    <td><input type="text" id="expensesEdit"/></td>
  </tr>
  <tr>
    <th>Profit:</th>
    <td><span id="profitSpan"></span></td>
  </tr>
</table>
#+END_SRC

/View-Model/

#+BEGIN_SRC js -n -r :exports code :tangle tangle/translator.js :padline no
// Define the model
var model = new hd.ModelBuilder()
    .v( 'income', 2000 )
    .v( 'expenses', 480 )
    .v( 'profit' )

    .c( 'income, expenses, profit' )
    .m( 'income, expenses -> profit', function( income, expenses ) {
      return income - expenses;
    } )

    .end();

// Create the constraint system
var system = new hd.ConstraintSystem();
system.addComponent( model );
#+END_SRC

/Binding/

#+BEGIN_SRC js -n -r :exports code :tangle tangle/translator.js :padline no
window.addEventListener( 'load', function() {
  var incomeObservable = new hd.BasicObservable();
  var incomeEdit = document.getElementById( 'incomeEdit' );
  incomeEdit.value = model.income.get();
  incomeEdit.addEventListener( 'input', function() {
    incomeObservable.sendNext( incomeEdit.value );
  } );

  var incomeTranslator = new hd.Translator();
  incomeTranslator.onNext = stringToNumber;

  incomeTranslator.addObserver( model.income );
  incomeObservable.addObserver( incomeTranslator );

  var expensesObservable = new hd.BasicObservable();
  var expensesEdit = document.getElementById( 'expensesEdit' );
  expensesEdit.value = model.expenses.get();
  expensesEdit.addEventListener( 'input', function() {
    expensesObservable.sendNext( expensesEdit.value );
  } );

  var expensesTranslator = new hd.Translator();
  expensesTranslator.onNext = stringToNumber;

  expensesTranslator.addObserver( model.expenses )
  expensesObservable.addObserver( expensesTranslator );

  var profitObserver = {
    onNext: function( v ) { setSpan( 'profitSpan', v ) },
    onError: function( e ) { },
    onCompleted: function() { }
  };

  var profitTranslator = new hd.Translator();
  profitTranslator.onNext = function( n ) {
    this.sendNext( n.toFixed( 2 ) );
  }

  model.profit.addObserverInit( profitTranslator );
  profitTranslator.addObserver( profitObserver );
} )

function stringToNumber( s ) {
  var n = Number( s );
  if (s == '' || isNaN( n )) {
    this.sendError( "Invalid number" );
  }
  else {
    this.sendNext( n );
  }
}

function setSpan( id, value ) {
  var span = document.getElementById( id );
  while (span.lastChild) { span.removeChild( span.lastChild ); }
  span.appendChild( document.createTextNode( value ) );
}

#+END_SRC

/Result/

#+HTML: <div class="results">
#+INCLUDE: tangle/translator.html html
#+HTML: </div>
#+HTML: <script type="text/javascript">
#+HTML: (function() {
#+INCLUDE: tangle/translator.js html
#+HTML: })();
#+HTML: </script>

/Notes/

#+HTML: <div class="notes">
This example keeps the same constraint as the previous two examples.  However,
rather than manually setting a variable with a button, this example
automatically sets variables every time the corresponding edit box is changed.
#+HTML: </div>


* Variables and binding

** The example

/View/

#+BEGIN_SRC html -n -r :exports code :tangle tangle/bind.html :padline no
<div>
  X: <input type="text" id="x_edit"/> &rArr; <span id="x_view"></span><br/>
  Y: <input type="text" id="y_edit"/> &rArr; <span id="y_view"></span><br/>
  Z: <span type="text" id="z_view"></span>
</div>
#+END_SRC

/View-Model/

#+BEGIN_SRC js -n -r :exports code :tangle tangle/bind.js :padline no
var model = new hd.ModelBuilder()
    .variable( 'x', 'Hello, HotDrink!' ) (ref:varx)
    .variable( 'y', 3 ) (ref:vary)
    .variable( 'z', {x: 0, y: 0} )
    .end();
#+END_SRC

/Binding/

#+BEGIN_SRC js -n -r :exports code :tangle tangle/bind.js :padline no
window.addEventListener( 'load', function() { (ref:onload)

  // Bind x to <input>
  hd.bind( {view:  new hd.Edit( document.getElementById( 'x_edit' ) ),
            model: model.x,
            dir:   hd.dir.bi
           }
         ); (ref:x1)

  // Bind x to <span>
  hd.bind( {view:  new hd.Text( document.getElementById( 'x_view' ) ),
            model: model.x,
            dir:   hd.dir.m2v
           }
         ); (ref:x2)

  // Bind y to <input>
  hd.bind( {view:    new hd.Edit( document.getElementById( 'y_edit' ) ),
            model:   model.y,
            dir:     hd.dir.bi,
            toModel: hd.toNum()
           }
         ); (ref:y1)

  // Bind y to <span>
  hd.bind( {view:  new hd.Text( document.getElementById( 'y_view' ) ),
            model: model.y,
            dir:   hd.dir.m2v
           }
         );

  // Bind z to mouse
  hd.bind( {view:  new hd.MousePosition(),
            model: model.z,
            dir:   hd.dir.v2m
           }
         );

  // Bind z to <span>
  hd.bind( {view:   new hd.Text( document.getElementById( 'z_view' ) ),
            model:  model.z,
            dir:    hd.dir.m2v,
            toView: hd.pointToString()
           }
         );
} );
#+END_SRC

/Result/

#+HTML: <div class="results">
#+INCLUDE: tangle/bind.html html
#+HTML: </div>
#+HTML: <script type="text/javascript">
#+HTML: (function() {
#+INCLUDE: tangle/bind.js html
#+HTML: })();
#+HTML: </script>

/Notes/

#+HTML: <div class="notes">
The value of variables ~x~ and ~y~ are each contained in an edit box and also
displayed in the page next to the edit box.  Editing the value changes the
text beside it --- though the ~y~ variable only changes when a valid number is
entered.  The variable ~z~ is set according to the mouse position and
displayed in the page.
#+HTML: </div>

** Creating variables

Just as in a programming language, values in HotDrink are stored in variables.
(Note, however, that HotDrink variables are /not/ the same as JavaScript
variables --- HotDrink variables are actually JavaScript objects.)

Variables are created with the model builder using the ~variable~ member
function and then stored in the model.  To create a variable you must specify
a name; you may optionally specify an initial value.  As with JavaScript
variables, uninitialized variables are given the value ~undefined~.  For
example, [[(varx)][line (varx)]] of the view-model creates a variable named ~x~ which is
initialized to the string "~Hello, world~".

The return value of the ~variable~ function is the builder itself.  This allows a
succinct programming style known as "chaining" in which multiple calls to
builder functions are joined together into a single expression.

The builder member functions get used frequently when declaring a property
model.  To make them easier to use, the model builder provides abbreviated
names for many of them.  For example, you may refer to the ~variable~ member
function simply as ~v~.  This is perhaps slightly less readable, but much
easier to type; we will use the abbreviated name ~v~ in the remainder of the
examples.

** Binding to the view

In order to make the data of the view-model visible in the view, we must
create a connection called a /binding/.  (Note: we use the word /binding/ both
as a noun to refer to the connection, and also as a verb to refer to the
process of creating the connection.)  A binding is created through the
~hd.bind~ function by passing it a binding specification.  We explain binding
in great detail in the [[file:binding.org][Advanced Binding Concepts]] how-to, but for now we will
examine just the fundamental concepts.

A binding specification contains two important elements: an object
representing the /view/, and an object representing the /model/.  These can be
any objects as long as they follow HotDrink's protocol for passing values
between objects.  (We discuss this in much more detail in the [[file:program.org][Programming
Guide]].)  Typically, the /model/ object will be a variable in the model, and
the /view/ object will represent some element in the web page.  We refer to
the view objects as /view adapters/ because they translate the various
interfaces of different DOM elements into the standard interface used by
HotDrink.

This example makes use of three view adapters.  The ~hd.Edit~ adapter
encapsulates a text edit box, using the value of the variable as the value of
the edit box.  The ~hd.Text~ adapter encapsulates any tag which may contain
text, using the value of the variable as the contents of the tag.  And the
~hd.MousePosition~ adapter encapsulates the mouse, using its current position
as the value of the variable.

Note that the ~hd.Edit~ and ~hd.Text~ adapters are initialized with the HTML
DOM node they are intended to encapsulate.  Remember that HTML DOM elements
are not available until their HTML has been processed by the browser.
Therefore, a good time to perform binding is immediately after your entire
document has been processed.  For purposes of this document, we accomplish
this by scheduling our binding to execute when the ~window.onload~ event
occurs.  You can see this on [[(onload)][line (onload)]] of the binding section above.  Many
JavaScript frameworks offer alternative methods of running code as soon as the
DOM is ready, and you are welcome to use them if you wish.

In addition to the ~view~ and ~model~ property, there are three optional
properties in a binding specification.  The ~dir~ property indicates the
direction of the binding.  There are three possible values for this property,
illustrated by the three different binding adapters we used in this example.
The binding for the ~hd.Text~ adapters goes only from the model to the view
--- that is, we always use the value of the model to set the value of the
view, never vice-versa.  This direction is indicated by the value
~hd.dir.m2v~.  Conversely, the binding for the ~hd.MousePosition~ adapter goes
only from the view to the model, as indicated by the value ~hd.dir.v2m~.  The
binding for the ~hd.Edit~ adapter is bi-directional, meaning that changing the
model updates the view /and/ changing the view updates the model.  This is
indicated by the value ~hd.dir.bi~.

Again, the ~dir~ property of a binding specification is optional; if it is
omitted, the system will attempt to deduce the direction based on the
interfaces supported by the objects.  Most of the time this is sufficient ---
in fact, in this example, none of the ~dir~ properties are actually needed.
The only time you must specify ~dir~ is if values /could/ be passed in both
directions but you want them passed in only one direction.

There other two optional properties are ~toModel~ and ~toView~.  If used,
these properties should refer to /transformation objects/ which modify the
values passed between objects.  Again, we defer in-depth discussion of this
for a later time, but for now notice the two transformations we use in the
example.  The variable ~z~ contains an object representing the current
coordinates of the mouse.  Thus, in order to bind this to a text binding, we
must transform the point object to a string using ~hd.pointToString~.  Since
that transformation takes place when the value is copied to the view, this is
a ~toView~ transformation.

Similarly, we wish for the variable ~y~ to contain a number.  Thus, we must
convert the string value of the edit box to a numeric value using ~hd.toNum~.
Since this transformation takes place when the value is copied to the model,
this is a ~toModel~ transformation.  If desired, we could specify a ~toView~
transformation to use to convert the number back to a string.  In this case we
choose not to, simply relying on JavaScript's built-in string coercion;
however, we a transformation could ensure the number is formatted as desired.

Note that certain transformations may fail in certain cases.  (For example,
try entering "abc" into the edit box for Y.)  When this happens, the value
will /not/ be passed from the view to the model (or from the model to the
view, depending on the direction).  Also, transformations may result in loss
of formatting, since formatting is a property of the string.  (For example,
try entering "1e3" into the edit box for Y.)
x
* Constraints and methods

** The example

/View/

#+BEGIN_SRC html -n -r :exports code :tangle tangle/constraint.html :padline no
<div style="display:inline-block; text-align:right">
  Income:   <input type="text" id="income"/><br/>
  Expenses: <input type="text" id="expenses"/><br/>
  Profit:   <input type="text" id="profit"/><br/>
</div>
#+END_SRC

/View-Model/

#+BEGIN_SRC js -n -r :exports code :tangle tangle/constraint.js :padline no
var model = new hd.ModelBuilder()
  .v( 'income', 1500 ).v( 'expenses', 900 ).v( 'profit' )

  // Constraint:  profit == income - expenses
  .constraint( 'income, expenses, profit' )
  .method( 'income, expenses -> profit', function( income, expenses ) {
    return income - expenses;
  } )
  .method( 'profit, expenses -> income', function( profit, expenses ) {
    return profit + expenses;
  } )
  .method( 'income, profit -> expenses', function( income, profit ) {
    return income - profit;
  } )

  .end();

var system = new hd.ConstraintSystem();
system.addComponent( model );
#+END_SRC

/Binding/

#+BEGIN_SRC js -n -r :exports code :tangle tangle/constraint.js :padline no
window.addEventListener( 'load', function() {
  hd.bind( {view:    new hd.Edit( document.getElementById( 'income' ) ),
            model:   model.income,
            toModel: hd.toNum()
           }
         );
  hd.bind( {view:    new hd.Edit( document.getElementById( 'expenses' ) ),
            model:   model.expenses,
            toModel: hd.toNum()
           }
         );
  hd.bind( {view:    new hd.Edit( document.getElementById( 'profit' ) ),
            model:   model.profit,
            toModel: hd.toNum()
           }
         );
} );
#+END_SRC


/Result/

# #+HTML: <div class="results">
# #+INCLUDE: tangle/constraint.html html
# #+HTML: </div>
# #+HTML: <script type="text/javascript">
# #+HTML: (function() {
# #+INCLUDE: tangle/constraint.js html
# #+HTML: })();
# #+HTML: </script>

/Notes/

#+HTML: <div class="notes">
Each time you make a change to one variable, the system automatically updates
another variable as well so that the equation "~profit == income - expenses~" is
always true.  The variable that is changed is always the variable you edited
/least/ recently.
#+HTML: </div>

** Constraints

A constraint is simply something that should always be true concerning some
(not necessarily all) of your variables.  When that thing is true, we say the
constraint is /satisfied/.  Exactly what it is that should be true is entirely
up to you.  Often it is a simple equation: in the example above, it is the
equation "~profit == income - expenses~."  But you might also have a
constraint that one number lies between the other two; or that the sum of all
three numbers is divisible by 7; or that a database lookup using the first two
numbers returns the third; and so on and so forth.

To define a constraint in HotDrink, all you need to specify is the variables
involved.  To make this simple, the ~constraint~ member function of the model
builder takes a string containing all of the variables' names in a
comma delimited list.  In [[(con)][line (con)]] above we define a constraint for the
variables ~income~, ~expenses~, and ~profit~.

The return value of the ~constraint~ member function is the builder, to
facilitate chaining. The ~constraint~ member function may be abbreviated as
~c~; we will use this abbreviation in the remainder of the examples.

** Methods

As stated above, the constraint can be whatever you want, but here's the
catch: you must tell HotDrink how to /enforce/ the constraint --- i.e.,
whenever the constraint is not satisfied, how can HotDrink change one or more
variables so that it is?  Each of these ways to enforce the constraint is
called a /constraint satisfaction method/, or just /method/ for short.

A method is always a function whose parameters are /some/
variables of the constraint, and which returns new values for /the other/
variables of the
constraint.  In the example above we provide three constraint satisfaction
methods: one on [[(mth1)][line (mth1)]], one on [[(mth2)][line (mth2)]], and one on [[(mth3)][line (mth3)]].  Each
one of these methods takes two of the variables and calculates a new value for
the third variable.

The method creation function of the model builder, named ~method~, takes a
signature and a function.  The signature is a string defining which variables
are inputs and which are outputs; it has the form "/inputs/ ~->~ /outputs/",
where both /inputs/ and /outputs/ are comma-delimited lists of variables. In
the example above we provide an anonymous function for each method, but this
is not a requirement; they can be named functions defined previously.

Note that it is not a requirement for function parameter names to match the
variables which should be passed to them; in fact, HotDrink has no way of
knowing what you named your parameters.  HotDrink will use the signature you
provided to decide what variables to pass to the function.

Whenever you call ~method~, HotDrink assumes you are adding a method to the most
recently defined constraint.  As with the other builder member functions, the
return value of ~method~ is the
builder to facilitate chaining, and it may be abbreviated as ~m~; we will use
this abbreviation in the remainder of the examples.

** Declaring the end

You begin a constraint using the ~constraint~ builder member function; you add
methods to it using ~method~; so how does the builder know when the constraint
is finished?  Well, it turns out there is a builder function named
~endConstraint~ which does just that.  Technically, the constraint is not
fully created until ~endConstraint~ is called.

That being said, many builder member functions (such as ~variable~,
~constraint~, ~result~, etc.) check to see if the builder has an unfinished
constraint and, if so, calls ~endConstraint~ for you.  The upshot is, most of
the time there is no need to call ~endConstraint~; it is only when you're
doing something unusual with the builder must you be aware of it.
Technically, your constraint has not been created until you call
~endConstraint~ or it is called for you.

* Connected constraints

** The example

/View/

#+BEGIN_SRC html -n -r :exports code :tangle tangle/multi-constraint.html :padline no
<table style="text-align: right">
  <tr>
    <td>
      Left:  <input type="text" id="left"/><br/>
      Right: <input type="text" id="right"/><br/>
      Width: <input type="text" id="width"/><br/>
    </td>
    <td>
      Top:    <input type="text" id="top"/><br/>
      Bottom: <input type="text" id="bottom"/><br/>
      Height: <input type="text" id="height"/><br/>
    </td>
  </tr>
  <tr>
    <td colspan="2" style="text-align:center">
      Aspect Ratio: <input type="text" id="aspect"/>
    </td>
  </tr>
</table>
#+END_SRC

/View-Model/

#+BEGIN_SRC js -n -r :exports code :tangle tangle/multi-constraint.js :padline no
// Helper functions
function sum ( x, y ) { return x + y; }
function diff( x, y ) { return x - y; }
function prod( x, y ) { return x * y; }
function quot( x, y ) { return x / y; }

var model = new hd.ModelBuilder()
  .variables( 'left, right, width, top, bottom, height, aspect', (ref:vs)
              {left: 0, right: 100, top: 60, bottom: 140}
  )

  // Constraint: width == right - left
  .c( 'left, right, width' )
  .m( 'left, width -> right', sum  )
  .m( 'right, left -> width', diff )
  .m( 'right, width -> left', diff )

  // Constraint: height == bottom - top
  .c( 'top, bottom, height' )
  .m( 'top, height -> bottom', sum  )
  .m( 'bottom, top -> height', diff )
  .m( 'bottom, height -> top', diff )

  // Constraint: aspect == width / height
  .c( 'width, height, aspect' )
  .m( 'height, aspect -> width', prod )
  .m( 'width, height -> aspect', quot )
  .m( 'width, aspect -> height', quot )

  .end();

var system = new hd.ConstraintSystem();
system.addComponent( model );
#+END_SRC

/Binding/

#+BEGIN_SRC js -n -r :exports code :tangle tangle/multi-constraint.js :padline no
window.addEventListener( 'load', function() {
  hd.bind( {view:    new hd.Edit( document.getElementById( 'left' ) ),
            model:   model.left,
            toModel: hd.toNum()
           }
         );
  hd.bind( {view:    new hd.Edit( document.getElementById( 'right' ) ),
            model:   model.right,
            toModel: hd.toNum()
           }
         );
  hd.bind( {view:    new hd.Edit( document.getElementById( 'width' ) ),
            model:   model.width,
            toModel: hd.toNum()
           }
         );
  hd.bind( {view:    new hd.Edit( document.getElementById( 'top' ) ),
            model:   model.top,
            toModel: hd.toNum()
           }
         );
  hd.bind( {view:    new hd.Edit( document.getElementById( 'bottom' ) ),
            model:   model.bottom,
            toModel: hd.toNum()
           }
         );
  hd.bind( {view:    new hd.Edit( document.getElementById( 'height' ) ),
            model:   model.height,
            toModel: hd.toNum()
           }
         );
  hd.bind( {view:    new hd.Edit( document.getElementById( 'aspect' ) ),
            model:   model.aspect,
            toModel: hd.toNum()
           }
         );
} );
#+END_SRC

/Result/

#+HTML: <div class="results">
#+INCLUDE: tangle/multi-constraint.html html
#+HTML: </div>
#+HTML: <script type="text/javascript">
#+HTML: (function() {
#+INCLUDE: tangle/multi-constraint.js html
#+HTML: })();
#+HTML: </script>

/Notes/

#+HTML: <div class="notes">
The seven variables of this UI are tied together by three different
interconnected constraints.  Editing one variable can result in several
different variables changing so that all values are consistent with one
another.
#+HTML: </div>

** Updating the constraint system

Whenever you modify any of the variables of the system, HotDrink assumes any
constraints which use those variables are no longer satisfied.  It then
performs two tasks.  The first is to decide which variable (or variables)
should be updated.  The second is to use a method (or methods) you provided to
calculate a new value for that variable (or variables).

Deciding which variables to update is not a trivial task.  Consider: the
variable ~left~ is modified, so HotDrink decides to update the ~width~
variable so that ~width == right - left~.  But now the constraint ~aspect ==
width / height~ is no longer satisfied, so HotDrink must update one of those
variables as well.  Thus, the effects of a single edit can cascade to multiple
variables.  HotDrink must consider the entire constraint system and decide
which variables will be used to update which other variables.  This plan for
how to update is called a /dataflow/.

Often there is more than one possible dataflow which could work.  In this
case, HotDrink will /generally/ select the dataflow which preserves variables
that have been more recently edited by the user.  (In certain unusual cases
the behavior is slightly more complicated, but this rule of thumb is close
enough for now.)  We believe this is generally what the user wants, as the
values more recently edited are more likely to reflect the user's current
intent.

** Declaring multiple variables at once

As you can see on [[(vs)][line (vs)]] of the view-model source, this example uses an
alternative approach to declaring variables.  The ~variables~ builder member
function takes two parameters.  The first is a string containing a
comma-delimited list of variables to create.  The second is an object used as
a map to provide initial values for variables.  If a variable does not contain
an entry in the map, it is treated as uninitialized, and therefore given the
value ~undefined~.

Note that the variables are created in the order in which they appear in the
string.  This is significant as the order in which variables are created
determines the initial editing order for the variables, and thus affects the
initial dataflow selected by the system.  Initializing a variable is treated
as an edit; creating an uninitialized variable is not treated as an edit.
Thus, the system will initially pick a dataflow that writes to uninitialized
variables; If any initialized variables need to be overwritten, the system
will choose to overwrite the variables created /earlier/, since those will be
considered less-recently edited.

The ~variables~ member function returns the builder.  The abbreviation for
~variables~ is ~vs~; we will use this abbreviation in the remainder of the
examples.

** Reusing functions

Notice that we can reuse the same function for multiple methods.  In this
example, we defined four simple mathematical functions at the top, then simply
used the appropriate function for each method.  Again, the values passed as
arguments will come from the variables specified in the signature.

In fact, if your constraints really are trivial equations such as this, there
is an even easier way to specify them.  We'll discuss that in the section
"[[* Shortcut: equations][Shortcut: equations]]".

* Input/output variables

** The example

/View/

#+BEGIN_SRC html -n -r :exports code :tangle tangle/io-param.html :padline no
<div style="display:inline-block; text-align:right">
  Begin: <input type="text" id="begin"/><br/>
  End:   <input type="text" id="end"/>
</div>
#+END_SRC

/Veiw-Model/

#+BEGIN_SRC js -n -r :exports code :tangle tangle/io-param.js :padline no
var model = new hd.ModelBuilder()
  .v( 'begin', 10 ).v( 'end', 20 )

   // Constraint: begin < end
  .c( 'begin, end' )
  .m( 'begin, end -> end', function( begin, end ) {
    return end < begin + 1 ? begin + 1 : end;
  } )
  .m( 'begin, end -> begin', function( begin, end ) {
    return begin > end - 1 ? end - 1 : begin;
  } )

  .end();

var system = new hd.ConstraintSystem;
system.addComponent( model );
#+END_SRC

/Binding/

#+BEGIN_SRC js -n -r :exports code :tangle tangle/io-param.js :padline no
window.addEventListener( 'load', function() {
  hd.bind( {view:    new hd.Edit( document.getElementById( 'begin' ) ),
            model:   model.begin,
            toModel: hd.toNum()
           }
         );
  hd.bind( {view:    new hd.Edit( document.getElementById( 'end' ) ),
            model:   model.end,
            toModel: hd.toNum()
           }
         );
} );
#+END_SRC

/Result/

#+HTML: <div class="results">
#+INCLUDE: tangle/io-param.html html
#+HTML: </div>
#+HTML: <script type="text/javascript">
#+HTML: (function() {
#+INCLUDE: tangle/io-param.js html
#+HTML: })();
#+HTML: </script>

/Notes/

#+HTML: <div class="notes">
The constraint here is acutally an inequality: ~begin <= end + 1~.  If you set one
variable so that the inequality holds, then the other variable is not
modified.  However, if you make the inequality false, then the other variable
is changed just enough to make the inequality true.
#+HTML: </div>

** The meaning of I/O parameters

When a method uses a variable for both input and output, the value given as
input is the /previous/ value of the variable --- the value it had after the
last time we enforced the constraint.  The value returned is the /next/ value
of the variable.

This may seem obvious, but it's an important point because, as a rule,
dependency cycles are not allowed.  A dependency cycle would be something like
this:  the value of ~a~ depends on ~b~, the value of ~b~ depends on ~c~, and
the value of ~c~ depends on ~a~.  You cannot solve such a system because
there's nowhere to start: every variable depends on something else.

I/O parameters do /not/ create dependency cycles because they effectively
reference two different variables: the pre-update variable and the post-update
variable.

** Caveat

Methods in HotDrink are generally assumed to not have side effects.  That is,
HotDrink assumes that if the parameters have not changed since the last time
the function was executed, that there is no reason to execute it again; it
will simply produce the same results.  Another way of saying this is: if
HotDrink executes a method to enforce one of your constraints, then
immediately executing the method again should have no effect.

You should write your methods with this in mind.  The methods given above
respect this assumption:  executing them immediately after they have just been
executed has no effect.  However, you should avoid methods like this:

#+BEGIN_SRC js
rt.builder( "n -> n", function( n ) {
  return n + 1;
} )
#+END_SRC

This method gives different results every time it is run, and may lead to
unexpected behavior.

* Multiple output variables

** The example

/View/

#+BEGIN_SRC html -n -r :exports code :tangle tangle/multi-out.html :padline no
<div style="display:inline-block; text-align:right">
  First Quarter:  <input type="text" id="q1"/><br/>
  Second Quarter: <input type="text" id="q2"/><br/>
  Third Quarter:  <input type="text" id="q3"/><br/>
  Fourth Quarter: <input type="text" id="q4"/><br/>
  <hr/>
  Full Year:      <input type="text" id="year"/><br/>
</div>
#+END_SRC

/View-Model/

#+BEGIN_SRC js -n -r :exports code :tangle tangle/multi-out.js :padline no
var model = new hd.ModelBuilder()
  .vs( 'q1, q2, q3, q4, year', {q1: 10, q2: 30, q3: 60, q4: 100} )

  .c( 'q1, q2, q3, q4, year' )
  .m( 'q1, q2, q3, q4 -> year',
      function( q1, q2, q3, q4 ) {
        return q1 + q2 + q3 + q4;
      }
   )
  .m( 'year, q1, q2, q3, q4 -> q1, q2, q3, q4', (ref:multi)
      function( year, q1, q2, q3, q4 ) {
        var diff = (year - q1 - q2 - q3 - q4) / 4;
        return [q1 + diff, q2 + diff, q3 + diff, q4 + diff ];
      }
  )

  .end();

var system = new hd.ConstraintSystem();
system.addComponent( model );
#+END_SRC

/Binding/

#+BEGIN_SRC js -n -r :exports code :tangle tangle/multi-out.js :padline no
window.addEventListener( 'load', function() {
  hd.bind( {view:    new hd.Edit( document.getElementById( 'q1' ) ),
            model:   model.q1,
            toModel: hd.toNum()
           }
         );
  hd.bind( {view:    new hd.Edit( document.getElementById( 'q2' ) ),
            model:   model.q2,
            toModel: hd.toNum()
           }
         );
  hd.bind( {view:    new hd.Edit( document.getElementById( 'q3' ) ),
            model:   model.q3,
            toModel: hd.toNum()
           }
         );
  hd.bind( {view:    new hd.Edit( document.getElementById( 'q4' ) ),
            model:   model.q4,
            toModel: hd.toNum()
           }
         );
  hd.bind( {view:    new hd.Edit( document.getElementById( 'year' ) ),
            model:   model.year,
            toModel: hd.toNum()
           }
         );
} );
#+END_SRC

/Result/

#+HTML: <div class="results">
#+INCLUDE: tangle/multi-out.html html
#+HTML: </div>
#+HTML: <script type="text/javascript">
#+HTML: (function() {
#+INCLUDE: tangle/multi-out.js html
#+HTML: })();
#+HTML: </script>

/Notes/

#+HTML: <div class="notes">
This is a straightforward constraint: the value for the year is the sum of the
values for the four quarters.  However, data can only flow two ways in this
constraint.  If any one of the quarters is modified, then the year is updated.
If the year is modified, then we take the difference and distribute it evenly
among the four quarters, thus satisfying the constraint.
#+HTML: </div>

** Multiple return values

For functions which must calculate values for multiple variables, we employ a
very simple convention:  the function returns an array of values.  We will use
the methods signature to decide which variables each element of the array
should be assigned to.  So, for the method on [[(multi)][line (multi)]] of the view-model
section, the first element of the array will go to ~q1~, the second to ~q2~,
and so on.

Note that your function should return an array /only/ if the method outputs to
multiple variables.  Methods which output to a single variable should always
return a single value.

* Shortcut:  declarative binding

** The example

/View/

#+BEGIN_SRC html -n -r :exports code :tangle tangle/decl-bind.html :padline no
<div id="ex6"> (ref:root)
  X: <input type="text" data-bind="{mkview: hd.Edit, model: x}"/> (ref:editx)
           &rArr; <span data-bind="{mkview: hd.Text, model: x}"></span><br/> (ref:textx)
  Y: <input type="text" data-bind="{mkview: hd.Edit, model: y, toModel: hd.toNum()}"/> (ref:edity)
           &rArr; <span data-bind="{mkview: hd.Text, model: y}"></span>                 (ref:texty)
</div>
#+END_SRC

/View-Model/

#+BEGIN_SRC js -n -r :exports code :tangle tangle/decl-bind.js :padline no
var model = new hd.ModelBuilder()
    .v( 'x', 'Hello, again!' ).v( 'y', 3 ).end();
#+END_SRC

/Binding/

#+BEGIN_SRC js -n -r :exports code :tangle tangle/decl-bind.js :padline no
window.addEventListener( 'load', function() {
  hd.performDeclaredBindings( model, document.getElementById( 'ex6' ) );
} ); (ref:bindTo)
#+END_SRC

/Results/

#+HTML: <div class="results">
#+INCLUDE: tangle/decl-bind.html html
#+HTML: </div>
#+HTML: <script type="text/javascript">
#+HTML: (function() {
#+INCLUDE: tangle/decl-bind.js html
#+HTML: })();
#+HTML: </script>

/Notes/

#+HTML: <div class="notes">
This is the same as the first example, except that it uses declarative binding
specifications.
#+HTML: </div>

** Automatic binding function

By now you've probably noticed that the binding section tends to be repetitive
and boring.  HotDrink offers two shortcuts to help alleviate this.  The first,
shown here, is allowing binding specifications to be embedded in the HTML.
There are two steps required for this.

*** Add binding specifications

The first step is to add markup in the HTML to describe how elements should be
bound.  To indicate that you wish to bind a variable to the node for an HTML
tag, simply add a ~data-bind~ attribute to the tag with the code for the
binding specification.  At run-time, HotDrink will evaluate this attribute
string as JavaScript code to take the result as the binding specification
object.

Note, however, one slight change to this binding specification.  In previous
examples our view object was a view adapter which encapsulated some DOM node
in the tree.  When you embed a binding specification in the HTML, HotDrink
assumes that a view adapter needs to be created for the DOM node.  Thus, it
looks for an attribute named "~mkview~".  This should be a constructor or
factory function which takes a single DOM node parameter.  HotDrink will use
this constructor or factory to create the view object, like so.

#+BEGIN_SRC js
specification.view = new specification.mkview( domNode );
#+END_SRC

Also notice that, in the binding specification, you may refer to the variable
by it's name in the model; e.g., the binding specification in [[(editx)][line (editx)]] of
the view section says "~target: x~" instead of "~target: rt.model.x~".
HotDrink will attempt to look up any variables referenced in the model you
pass to the binding function (see below); if it cannot find it in the model,
it will treat it as a global variable.

*** Call the binding function

The second step is to call the HotDrink function to performs the binding.  You
can do this as follows.

#+BEGIN_SRC js
hd.performDeclaredBindings( mod, document.getElementById( 'ex6' ),  );
#+END_SRC

This function takes two parameters: a model to use, and a DOM node at which to
start searching.  This function will search the DOM node passed to it and any
DOM nodes under it for elements with a ~data-bind~ attribute.  When it finds
one, it evaluate the binding specification as described above and then pass it
to ~hd.bind~.

In the example above, HotDrink would examine all tags contained by the ~<div>~
tag in [[(root)][line (root)]] of the view.  It would evaluate the binding specifications
for each of the four tags with ~data-bind~ attributes.  Then it will attempt
to bind according to each of those specifications.

The second parameter is optional; it defaults to ~document.body~ so that the
entire document will be searched.  Note, however, that this could cause
problems if you are binding different models to different parts of the
document (for example, as we are in this document).

As with manual binding, you must ensure that the nodes involved have been
added to the DOM /before/ calling ~performDeclaredBindings~; therefore, it is
advised to use the ~window.onload~ event or some alternative method of
executing code after the DOM is fully ready.

* Shortcut: binding specification factories

** The example

/View/

#+BEGIN_SRC html -n -r :exports code :tangle tangle/fact-bind.html :padline no
<div id="ex7"> (ref:root)
  X: <input type="text" data-bind="hd.edit( x )"/> (ref:editx)
           &rArr; <span data-bind="hd.text( x )"></span><br/> (ref:textx)
  Y: <input type="text" data-bind="hd.num( y )"/> (ref:edity)
           &rArr; <span data-bind="hd.text( y )"></span>                 (ref:texty)
</div>
#+END_SRC

/View-Model/

#+BEGIN_SRC js -n -r :exports code :tangle tangle/fact-bind.js :padline no
var model = new hd.ModelBuilder()
    .v( 'x', 'Hello, again!' ).v( 'y', 3 ).end();
#+END_SRC

/Binding/

#+BEGIN_SRC js -n -r :exports code :tangle tangle/fact-bind.js :padline no
window.addEventListener( 'load', function() {
  hd.performDeclaredBindings( model, document.getElementById( 'ex7' ) );
} ); (ref:bindTo)
#+END_SRC

/Results/

#+HTML: <div class="results">
#+INCLUDE: tangle/fact-bind.html html
#+HTML: </div>
#+HTML: <script type="text/javascript">
#+HTML: (function() {
#+INCLUDE: tangle/fact-bind.js html
#+HTML: })()
#+HTML: </script>

/Notes/

#+HTML: <div class="notes">
This is the same as the previous example, except the binding specification
objects are created using factory functions.
#+HTML: </div>

** Factory functions

Binding specification objects tend to be lengthy and follow the same basic
patterns.  Since the ~data-bind~ attribute is simply evaluated as JavaScript
code, we can use any JavaScript code we want to create these objects --- e.g.,
call a factory function to create the object for us.

HotDrink provides several factory functions for creating these objects.  There
is nothing special about these factory functions, and you are encouraged to
make your own.  For example, the function ~hd.edit~ looks basically like the
following:

#+BEGIN_SRC js
hd.edit = function( model, toView, toModel ) {
  return {mkview:  hd.Edit,
          model:   model,
          toView:  toView,
          toModel: toModel
         };
}
#+END_SRC

A full list of the factory functions can be found in the [[file:binding.org][Advanced Binding
Concepts]] how-to, but for now we point out the following three:

1. The ~hd.edit~ factory creates the binding specification for a text edit
   box.
2. The ~hd.num~ factory also creates a specification for a text edit box,
   but the value is converted to a number before passing it to the model.
   Note that this factory takes a second optional argument which is used to
   specify the number of digits after the decimal point.
3. The ~hd.text~ factory creates the binding specification for replacing the
   contents of a tag with the value of a variable.

* Shortcut: equations

** The example

/View/

#+BEGIN_SRC html -n -r :exports code :tangle tangle/eq.html :padline no
<table style="text-align: right" id="ex8">
  <tr><td>
    Account Balance: <input type="text" data-bind="hd.num( balance, 2 )"/><br/>
    Minimum Percentage: <input type="text" data-bind="hd.num( min_rate, 3 )"/><br/>
    Minimum Payment: <input type="text" data-bind="hd.num( min_pay, 2 )"/><br/>
    <hr/>
    Payment Made: <input type="text" data-bind="hd.num( pay, 2 )"/>
  </td></tr>
</table>
#+END_SRC

/View-Model/

#+BEGIN_SRC js -n -r :exports code :tangle tangle/eq.js :padline no
var model = new hd.ModelBuilder()
  .vs( 'balance, min_rate, min_pay, pay', {balance: 4000, min_rate: 6.125} )
  .equation( "min_pay == balance * min_rate / 100" )
  .equation( "pay >= min_pay" )
  .end();

var system = new hd.ConstraintSystem();
system.addComponent( model );

window.addEventListener( 'load', function() {
  hd.performDeclaredBindings( model, document.getElementById( 'ex8' ) );
} );
#+END_SRC

/Result/

#+HTML: <div class="results">
#+INCLUDE: tangle/eq.html html
#+HTML: </div>
#+HTML: <script type="text/javascript">
#+HTML: (function() {
#+INCLUDE: tangle/eq.js html
#+HTML: })();
#+HTML: </script>

/Notes/

#+HTML: <div class="notes">
In this example we can calculate the minimum payment required on an account
balance based on a given percentage of the balance.  We can also specify the
actual payment made, though it must be higher than the minimum.
#+HTML: </div>

** Allowable equations

HotDrink is /not/ a program for solving mathematical equations.  However,
simple equations like the ones in this example are common and are not hard to
solve.  Therefore, as a convenience, HotDrink provides this shortcut method
for creating constraints from /simple/ equations.

The equations which HotDrink can enforce are those in which (1) no variable
appears in the equation more than once, and (2) the only operations are add
(~+~), subtract (~-~), multiply (~*~), and divide (~/~).  This means, e.g., no
exponents, no square roots, etc.

Note that, despite the name, the ~equation~ member function can also parse
inequalities.  Thus, the allowable comparison operators in an equation are
~==~, ~<=~, and ~>=~.

Examples of valid equations:

- ~width == right - left~
- ~aspect == width / height~
- ~surface == (2*width + 2*length) * height~

Examples of invalid equations:

- ~perimeter = width + height + width + height~
- ~area == 3.14*radius^2~
- ~side == sqrt(area)~

** Implementation

HotDrink implements these equations by parsing them and then, for each
variable, constructing a function which solves for that variable.  Each of
these functions becomes a method.  Thus, the constraint will have as many
methods as there are variables, with each method updating exactly one
variable.

To be clear, the ~equation~ function's only advantage is that it saves you
some typing; in the end you still get a regular constraint.  Therefore, in the
example from section [[*Constraints and methods]], replacing the constraint
specification with ~equation( "profit == income - expenses" )~ would result in
the /exact/ same constraint.

If, for any method, the solution involves a division by zero, then the
variable will not be updated and the constraint will not be satisfied.

As you probably expect by now, the ~equation~ member function returns the
builder.  It can be abbreviated ~eq~.
