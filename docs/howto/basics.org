#+TITLE: Basic HotDrink Usage
#+LANGUAGE:  en
#+OPTIONS: H:2 author:nil creator:nil
#+HTML_HEAD_EXTRA: <script type="text/javascript" src="hotdrink.min.js"></script>
#+HTML_HEAD_EXTRA: <script type="text/javascript" src="collapse.js"></script>
#+HTML_HEAD_EXTRA: <link rel="stylesheet" type="text/css" href="style.css"/>

* Introduction

This document describes the basics of how to create a property model, and how
that property model operates and interacts with the rest of your web
application.  We feel that you should not have to use a library without
understanding exactly how it is working and what it is doing for you.
Therefore, in this document we set aside the shortcuts and convenience
functions of HotDrink so that it will be clear exactly how a property model
works.  Then we slowly lay the groundwork for the shortcuts, making it clear
what they are doing for you.  After reading this document, you should have a
foundation for understanding what HotDrink is doing without feeling like it is
\ldquo{}magic\rdquo.

* Creating a constraint system

The most fundamental part of a GUI written with HotDrink is the constraint
system which represents data dependencies in your GUI.  This first example
shows how to create variables and constraints for that system, and how you can
directly interact with variables.

We assume here that you have read the document [[file:intro.org][Introduction to HotDrink]] and
are therefore familiar with the basic concept of a constraint system.

** The example

This example shows a single constraint of three variables: /emails/, /filter/,
and /result/.  Each of these variables holds a string.  The value of /emails/
is a comma-delimited list of email addresses.  The value of /filter/ is any
string.  The value of /result/ is the comma-delimited list of just those
addresses in /emails/ which contain /filter/ as a substring.

You can use the "Set" buttons to set the values of the /emails/ and /filter/
variables.  Then click the "Get" button to see the value of the /result/
variable.

#+HTML: <div class="results">
#+INCLUDE: tangle/barebone.html html
#+HTML: </div>
#+HTML: <script type="text/javascript">
#+HTML: (function() {
#+INCLUDE: tangle/barebone.js html
#+HTML: })();
#+HTML: </script>

*Source Code*

The entire source code for this example is shown in its entirety below.
(Click the "show" links to view the code.)  To clarify, we have broken code
into three sections: the HTML that defines the View, the JavaScript that
defines the View-Model, and the JavaScript that binds the View to the
View-Model.  In the remainder of this section we will reproduce and examine
snippets of this code.

Note that, in this example, we deliberately avoid using any sort of binding
mechanisms and interact directly with the property model.  This makes the
example a little awkward, but also makes clear how the property model works.

#+CAPTION: /View/ (show/hide)
#+BEGIN_SRC html -n :exports code :tangle tangle/barebone.html :padline no
<table>
  <style type="text/css" scoped>
    td { padding-right: 1ex; }
    th { padding-right: 1ex; text-align: left; font-weight: bold; }
  </style>
  <tr>
    <th>Emails:</th>
    <td><input type="button" value="Set" onclick="setEmails()"/></td>
  </tr>
  <tr>
    <th>Filter:</th>
    <td><input type="button" value="Set" onclick="setFilter()"/></td>
  </tr>
  <tr>
    <th>Result:</th>
    <td><input type="button" value="Get" onclick="getResult()"/></td>
  </tr>
</table>
#+END_SRC

#+CAPTION: /View-Model/ (show/hide)
#+BEGIN_SRC js -n :exports code :tangle tangle/barebone.js :padline no :noweb yes
// Define the context
var context = new hd.ContextBuilder()
    // Define variables
<<emailvar>>
    .variable( 'filter', 'foo.com' )
    .variable( 'result' )

    // Define a constraint
<<emailcon>>
<<emailmth>>

    // Get resulting context
    .context();

// Create the property model
var pm = new hd.PropertyModel();
pm.addComponent( context );
<<update>>
#+END_SRC

#+CAPTION: /Binding/ (show/hide)
#+BEGIN_SRC js -n :exports code :tangle tangle/barebone.js :padline no :noweb yes

// Allow user to set emails variable
<<setemails>>

// Allow user to set filter variable
setFilter = function setFilter() {
  var filter = window.prompt( 'Filter:', context.filter.get() );
  if (filter !== null) {
    context.filter.set( filter );
    pm.update();
  }
}

// Present result to user
<<getResult>>
#+END_SRC

** Working with the context builder

Recall from [[file:intro.org][the introduction]] that the context builder is a factory object for
creating contexts.  The general strategy for constructing a context is: (1.)
create a new builder object, (2.) use the builder member functions to
construct the context, (3.) call the ~context~ builder member function to
retrieve the completed context.

Generally, building a context involves the following steps.

*** Creating variables

Just as in a programming language, values in HotDrink are stored in variables.
Note, however, that HotDrink variables are /not/ the same as JavaScript
variables; HotDrink variables are actually JavaScript objects.  Variables are
created with the model builder using the ~variable~ member function and then
stored in the model.  To create a variable you must specify a name; you may
optionally specify an initial value.  As with JavaScript variables,
uninitialized variables are given the value ~undefined~.  For example, the
line below creates a variable named ~emails~ which is initialized with a list
of email addresses.

#+NAME: emailvar
#+BEGIN_SRC js
    .variable( 'emails', 'joe@foo.com, sue@fum.edu, eve@foo.com, bob@baz.org' )
#+END_SRC

As mentioned previously, the return value of the ~variable~ function is the
builder object itself in order to facilitate chaining.

Builder member functions such as ~variable~ are used frequently when declaring
a property model.  To make them easier to use, the model builder provides
abbreviated names for many of them.  For example, you may refer to the
~variable~ member function simply as ~v~.  This is perhaps slightly less
readable, but much easier to type; we will use the abbreviated name ~v~ in the
remainder of the examples.

*** Creating constraints

Recall from [[file:intro.org][the introduction]] that a constraint is something that should always
be true concerning some of your variables---i.e., a /relation/ over the
variables.  In the example above, the relation is that ~result~ should contain
just those addresses in ~emails~ for which ~filter~ is a substring.

To define a constraint, you must specify the variables involved.  To make this
simple, the ~constraint~ member function of the model builder takes a string
containing all of the variables' names in a comma delimited list.  In this
example we define a single constraint for the variables ~emaisl~, ~filter~, and
~result~, as shown on the line below.

#+NAME: emailcon
#+BEGIN_SRC js
    .constraint( 'emails, filter, result' )
#+END_SRC

The return value of the ~constraint~ member function is the builder. The
~constraint~ member function may be abbreviated as ~c~; we will use this
abbreviation in the remainder of the examples.

*** Creating methods

Notice that, when you create a constraint, you do /not/ tell HotDrink what
relation the constraint represents.  Instead, you define a constraint by
providing /constraint satisfaction methods/, or just /methods/ for short.  A
method is a function whose parameters are /some/ variables of the constraint,
and which returns new values for /other/ variables of the constraint.  The
purpose of a method is to provide new values for its output variables that
will satisfy the constraint.

The method creation function of the model builder, named ~method~, takes a
signature and a function.  The signature is a string defining which variables
are inputs and which are outputs; it has the form "/inputs/ ~->~ /outputs/",
where both /inputs/ and /outputs/ are comma-delimited lists of variables.  For
this example we provide only a single method, shown below.  This method takes
~emails~ and ~filter~ and uses them to calculate ~result~.  You can have more
than one method per constraint; we'll discuss this further in later examples.

#+NAME: emailmth
#+BEGIN_SRC js
    .method( 'emails, filter -> result',
             function( emails, filter ) {
               var words = emails.trim().split( /\s*,\s*/ );
               var filteredWords = words.filter( function( word ) {
                 return word.indexOf( filter ) > -1;
               } );
               return filteredWords.join( ', ' );
             } )
#+END_SRC

Note that in this example we provide an anonymous function as our method, but
this is not a requirement; methods can be named functions defined elsewhere.
Also note that it is not a requirement for function parameter names to match
the variables which should be passed to them; in fact, HotDrink has no way of
knowing what you named your parameters.  HotDrink will use the signature you
provided to decide what variables to pass to the function.

Whenever you call ~method~, the builder assumes you are adding a method to the
most recently defined constraint.  As with the other builder member functions,
the return value of ~method~ is the builder to facilitate chaining, and it may
be abbreviated as ~m~; we will use this abbreviation in the remainder of the
examples.

** Interacting with variables

Variables can be accessed via the context; for example, if your context is
stored in a variable named ~context~, then the variable ~emails~ is accessed
as ~context.emails~.  The value of variables can be retrieved using the ~get~
member function and modified using the variable's ~set~ member function.  If a
variable is registered with a property model (i.e., the variable is in a
context that has been added to the constraint system), then changes to the
variable's value will be noticed by the property model.

In the example above, the following function is called every time the user
clicks the "Get" button.  The function calls ~context.result.get~ to retrieve
the current value of the ~result~ variable; it then displays this value using
the standard ~alert~ function.


#+NAME: getresult
#+BEGIN_SRC js
getResult = function getResult() {
  alert( 'Result: ' + context.result.get() );
}
#+END_SRC

The following function is called every time the user clicks the "Set" button
for the email address list.  The function calls ~context.emails.get()~ to
retrieve the current value of the ~emails~ variable; this is used to
initialize the prompt.  Once the user enters a new value, it uses
~context.emails.set()~ to store it in the variable.

#+NAME: setemails
#+BEGIN_SRC js
setEmails = function setEmails() {
  var emails = window.prompt( 'Emails:', context.emails.get() );
  if (emails !== null) {
    context.emails.set( emails );
    pm.update();
  }
}
#+END_SRC

Note that in the next section we will introduce binding, which is a better way
to set and get variable values.

** Updating the property model

To /update/ the property model means to respond to changes that have been
made---such as added constraints or modified variables---by enforcing any
constraints which may no longer be satisfied.  The constraint system notices
when changes occur, and remembers the changes.  However, the constraint system
does not actually update until its ~update~ member function is called, as
shown below.  This allows you to package several changes into a single update.
In the example above, we call ~update~ after adding our context to the
property model, as well as after setting a variable.

#+NAME: update
#+BEGIN_SRC js
pm.update();
#+END_SRC

A more common way of updating the property model is by executing a /command/.
We will discuss commands a little later.

* Simplified binding

The previous example illustrates the simplest possible interaction with the
property model: getting and setting a variable's value, and updating the
property model.  However, most commonly we do not get and set variable value's
directly; instead we rely on /bindings/ to get and set them for us.  In this
example, we'll write our own very simple bindings to illustrate how this
process works.


The previous example interacted with the property model using only the ~get~
and ~set~ functions for variables.  In actuality, this is not the best way to
interact with variables of the property model because the property model
updates /asynchronously/.  This means that calling ~pm.update()~ does not
actually force the property model to update, but rather requests that it
update itself at the next available time.  Thus, you cannot be sure when a
variable's value will be updated.

A better way to interact with variables of the property model is by letting
them tell /you/ when they have updated.  A variable has an event that is
triggered every time its value changes.  We can register a callback function
for this event so that we update the web page every time the variable changes.
Similarly, most HTML input elements have an event that is triggered every time
their value changes.  We can register a callback function for this event so
that every time its.  Together, these callback functions represent a
/binding/---a connection between an element of the View and an element of the
View-Model.

** The example

This example is very similar to the previous:  a list of email addresses which
is filtered by a string.  The difference is in the way we interact with the
property model.  In this example, the ~emails~ and ~filter~ variables are
represented by text boxes: editing the text boxes changes the variables.
Also, the value of the ~result~ variable is shown in the web page and updated
automatically.

#+HTML: <div class="results">
#+INCLUDE: tangle/observe.html html
#+HTML: </div>
#+HTML: <script type="text/javascript">
#+HTML: (function() {
#+INCLUDE: tangle/observe.js html
#+HTML: })();
#+HTML: </script>

*Source Code*

Again, in this example we forgo using HotDrink's binding mechanisms and write
our own binding mechanisms instead.  The purpose of this is to illustrate the
work involved in binding.

Note that the View-Model of this example is identical to the previous example;
only the View and Binding have changed.

#+CAPTION: /View/ (show/hide)
#+BEGIN_SRC html -n :exports code :tangle tangle/observe.html :padline no
<table>
  <style type="text/css" scoped>
    th { padding-right: 1ex; text-align: left; font-weight: bold; }
    input.long { width: 100ex; }
  </style>
  <tr>
    <th>Emails:</th>
    <td><input type="text" id="emailsEdit" class="long"/></td>
  </tr>
  <tr>
    <th>Filter:</th>
    <td><input type="text" id="filterEdit" class="long"/></td>
  </tr>
  <tr>
    <th>Result:</th>
    <td><span id="resultSpan"></span></td>
  </tr>
</table>
#+END_SRC

#+CAPTION: /View-Model/ (show/hide)
#+BEGIN_SRC js -n :exports code :tangle tangle/observe.js :padline no
// Define the context
var context = new hd.ContextBuilder()
    .v( 'emails', 'joe@foo.com, sue@fum.edu, eve@foo.com, bob@baz.org' )
    .v( 'filter', 'foo.com' )
    .v( 'result' )

    .c( 'emails, filter, result' )
    .m( 'emails, filter -> result',
        function( emails, filter ) {
          var words = emails.trim().split( /\s*,\s*/ );
          var filteredWords = words.filter( function( word ) {
            return word.indexOf( filter ) > -1;
          } );
          return filteredWords.join( ', ' );
        } )

    .context();

// Create the property model
var pm = new hd.PropertyModel();
pm.addComponent( context );
#+END_SRC

#+CAPTION: /Binding/ (show/hide)
#+BEGIN_SRC js -n :exports code :tangle tangle/observe.js :padline no :noweb yes
// To be done when the document has loaded...
window.addEventListener( 'load', function() {

  // When emails edit-box changed, update variable
  var emailsEdit = document.getElementById( 'emailsEdit' );
  emailsEdit.value = context.emails.get();
<<emailsEdit>>

  // When filter edit-box changed, update variable
  var filterEdit = document.getElementById( 'filterEdit' );
  filterEdit.value = context.filter.get();
  filterEdit.addEventListener( 'input', function() {
    context.filter.set( filterEdit.value );
    pm.update()
  } );

  // When result variable changed, update span
  var resultSpan = document.getElementById( 'resultSpan' );
  resultSpan.appendChild( document.createTextNode( context.result.get() ) );
<<resultSpan>>

} )
#+END_SRC

** A view-to-model binding

One job of a binding is to ensure that, if the user modifies a value in the
View, the corresponding variable is modified as well.  To accomplish this, we
register an event handler for the ~input~ event of the text-edit input, as
shown below.  The ~addEventListener~ function is the standard function for
registering a callback function for an HTML DOM node.

#+NAME: emailsEdit
#+BEGIN_SRC js
  emailsEdit.addEventListener( 'input', function() {
    context.emails.set( emailsEdit.value );
    pm.update()
  } );
#+END_SRC

The callback function we register simply uses the value of the text-edit input
to update the property model variable, then updates the property model.  Now,
every time the user edits the text input, the variable will be set to the same
value.

** A model-to-view binding

The other job of a binding is to ensure that, if the value of a variable
changes, the corresponding element of the View is modified as well.  Just like
DOM nodes, variables have an event that triggers every time its value is
modified.  Although the syntax for registering a callback is slightly
different, the semantics is the same.

#+NAME: resultSpan
#+BEGIN_SRC js
  context.result.addObserver( { onNext: function() {
    resultSpan.removeChild( resultSpan.lastChild );
    resultSpan.appendChild( document.createTextNode( context.result.get() ) );
  } } );
#+END_SRC

The callback function we register here simply deletes the old contents of the
~<span>~ tag and then adds the value of the variable as the new contents.
Now, every time the variable is modified, the span tag will be updated to
reflect the same value.

The interfaces for registering callbacks for events and for publishing your
own events for HotDrink to listen to is discussed in the [[file:binding.org][Advanced Binding
Concepts]] howto.

** A bi-directional binding

A bi-directional binding is simply a pair of bindings: one from view-to-model,
and one from model-to-view.  Together, these bindings ensure that any changes
in the View are propagated to the property model, and any changes in the
property model are propagated to the view.

** The importance of binding

Binding code tends to be highly reusable.  For example, we might write a
binding for a text-edit input, or for a span tag, and then reuse them any time
we want to bind to these elements.  This can often make binding a simple
matter of a few lines of code.

There is another important reason why we should use binding instead of simply
using the ~get~ and ~set~ methods of a variable directly.  Property models
update /asynchronously/.  This is discussed in depth in the [[file:async.org][Asynchronous
Methods]], but the important detail for now is that calling ~update~ on the
property model does /not/ execute any methods of the property model.  Instead,
it /schedules/ them to be run as soon as their inputs are available.

For example, consider the following code segment.

#+BEGIN_SRC js
context.filter.set( '.edu' );
pm.update();
alert( context.result.get() );
#+END_SRC

In this segment we set the value of a variable, update the property model,
then read the value of a different variable.  If you were to execute this
code, you would find the value of ~result~ that you read is /not/ the updated
value of ~result~; it is still the old value.  The new value won't be ready
until your method has a chance to execute.

This is why it is so important that we register a callback to run when the
variable changes.  As a general rule, we cannot be sure when the new value of
a variable will be ready.  By registering a callback, we allow the property
model to tell us when a new value of the variable is available.

* Adapters and translators

If we were to combine the observable and observer objects of the previous
example, we would get a single object, both observable and an observer, which
representing a text edit box of the View: when the object observes a value, it
updates the text box to contain that value, and when the user edits the text
box, it notifies any observers with the new value.  This object is called a
/view adapter/ because it converts the interface of the View---i.e., an HTML
DOM node---into the observable/observer interface used by HotDrink.

Often when a variable is bound to the view, the value contained in the View
will be slightly different than the value contained in the property model.  A
good example of this is a variable whose value is a number bound to a text box
whose value is a string.  While it is possible for an adapter to make such
data conversions, creating a separate object specifically to do this
conversion, called a /translator/, allows more flexibility by making it easy
to combine different adapters with different translators.

** The example

This example also contains a single constraint.  This time, the constraint
represents the mathematical equation, $income - expenses = profit$.  As with
the previous example, updating the text boxes will cause the result to update
automatically.

This example utilizes some new binding techniques, including the ability to
convert between string values in the View and numeric values in the View-Model.

#+HTML: <div class="results">
#+INCLUDE: tangle/translator.html html
#+HTML: </div>
#+HTML: <script type="text/javascript">
#+HTML: (function() {
#+INCLUDE: tangle/translator.js html
#+HTML: })();
#+HTML: </script>

*Source Code*

#+CAPTION: /View/ (show/hide)
#+BEGIN_SRC html -n :exports code :tangle tangle/translator.html :padline no
<table>
  <style type="text/css" scoped>
    th { padding-right: 1ex; text-align: left; font-weight: bold; }
  </style>
  <tr>
    <th>Income:</th>
    <td><input type="text" id="incomeEdit"/></td>
  </tr>
  <tr>
    <th>Expenses:</th>
    <td><input type="text" id="expensesEdit"/></td>
  </tr>
  <tr>
    <th>Profit:</th>
    <td><span id="profitSpan"></span></td>
  </tr>
</table>
#+END_SRC

#+CAPTION: /View-Model/ (show/hide)
#+BEGIN_SRC js -n :exports code :tangle tangle/translator.js :padline no
// Define the context
var context = new hd.ContextBuilder()
    .v( 'income', 2000 )
    .v( 'expenses', 480 )
    .v( 'profit' )

    .c( 'income, expenses, profit' )
    .m( 'income, expenses -> profit',
        function( income, expenses ) {
          return income - expenses;
        } )

    .context();

// Create the constraint system
var pm = new hd.PropertyModel();
pm.addComponent( context );
#+END_SRC

#+CAPTION: /Binding/ (show/hide)
#+BEGIN_SRC js -n :exports code :tangle tangle/translator.js :padline no :noweb yes
// To be done when the document has loaded...
window.addEventListener( 'load', function() {

<<edit-adapter>>
<<number-translator>>
<<connections>>

  // An adapter for the <input> element for expenses
  var expensesAdapter = new hd.Edit( document.getElementById( 'expensesEdit' ) );
  // A translator from string to number
  var expensesTranslator = new hd.Translator();
  expensesTranslator.onNext = stringToNumber;
  // Connect observables to observers
  expensesTranslator.addObserver( context.expenses )
  expensesAdapter.addObserver( expensesTranslator );
  context.expenses.addObserver( expensesAdapter );

<<text-adapter>>
<<fixed-translator>>
  // Connect observables to observers
  context.profit.addObserver( profitTranslator );
  profitTranslator.addObserver( profitAdapter );
} )

<<string-to-number>>

<<fix2>>
#+END_SRC


** View adapters

A /view adapter/ is an object which represents some element of the view which
can be bound to a property model.  It is called an /adapter/ because it adapts
the view element's interface to the observable/observer interface expected by
HotDrink.  A view adapter may be read-only (i.e., observable-only), read-write
(i.e., observable-observer), or write-only (i.e., observer-only).  For
example, an adapter for the mouse cursor position would be read-only; an
adapter for a text box would be read-write; and an adapter for a <span> tag
would be write-only.

HotDrink provides several types of view adapters for common input elements.
We describe them in detail in the [[file:binding.org][Advanced Binding Concepts]] how-to.  For now,
however, we introduce two adapters for use in the remainder of this how-to.

The first adapter type is the ~Edit~ adapter: a read-write adapter that
represents the value of a text box.  As an observable, the ~Edit~ adapter
reports every time the value of the text box changes.  As an observer, the
~Edit~ adapter updates the value of the text box every time the value of the
variable being observed changes.  To create an ~Edit~ adapter, simply create a
new ~hd.Edit~ object passing the DOM node for the text box to the constructor.

#+NAME: edit-adapter
#+BEGIN_SRC js
  // An adapter for the <input> element for income
  var incomeAdapter = new hd.Edit( document.getElementById( 'incomeEdit' ) );
#+END_SRC

Adapters can be creative in the way they choose to read or write values.  For
example, the ~Edit~ adapter does not report a new value with every keystroke;
it waits for either a half-second pause in the typing, or for an event that
indicates that the edit is complete, such as the user pressing the Enter key
or the text box losing focus.  Furthermore, if the adapter receives a new
value while the user is editing, the adapter waits until the text box loses
focus before updating its value.

The second adapter type is the ~Text~ adapter: a read-only adapter that
represents the text contents of a tag.  As an observer, the ~Text~ adapter
update the contents of its tag every time the value of the variable being
observed changes.  To create a ~Text~ adapter, simply create a new ~hd.Text~
object passing the DOM node for the tag to the constructor.

#+NAME: text-adapter
#+BEGIN_SRC js
  // An adapter for the <span> element for profit
  var profitAdapter = new hd.Text( document.getElementById( 'profitSpan' ) );
#+END_SRC

** Translators

The purpose of a translator is to convert a value between the format expected
by the View to the format expected by the View-Model.  A translator is both an
observable and an observer:  it observes the value of the View (or View-Model)
and produces a value for the View-Model (or the View).

Creating a translator is not hard, but it does tend to involve a lot of
boiler-plate code.  For this reason, HotDrink provides a simple implementation
of a translator called ~Translator~.  You may create instances of this type,
or use it as a prototype for your own JavaScript types.  As it is written,
this translator performs no translation; it simply takes the value it was
given and passes it on.  However, by assigning the translator a new ~onNext~
method, we can cause it to modify the values it is given.

#+NAME: number-translator
#+BEGIN_SRC js
  // A translator from string to number
  var incomeTranslator = new hd.Translator();
  incomeTranslator.onNext = stringToNumber;
#+END_SRC

The prototype for the ~Translator~ type is a ~BasicObservable~.  Thus, after
you have translated your value, you can use ~sendNext~ to pass on the
translated value.  Alternatively, you can use ~sendError~ to signal an error.

#+NAME: string-to-number
#+BEGIN_SRC js
// Helper function for translator:  convert string to number
function stringToNumber( s ) {
  var n = Number( s );
  if (s == '' || isNaN( n )) {
    this.sendError( "Invalid number" );
  }
  else {
    this.sendNext( n );
  }
}
#+END_SRC

Note that, while we could create an adapter to convert the number of the
View-Model to a string for the View, it is not strictly necessary.  JavaScript
will automatically convert our number to a string using ~toString~ when it is
assigned as the value of a text box.  This is sufficient for our text boxes.
However, in the case of our ~<span>~ tag, we would prefer to use
~toFixedString~ instead.  Thus, we define a translator for this tag.

#+NAME: fixed-translator
#+BEGIN_SRC js
  // A translator from number to string
  var profitTranslator = new hd.Translator();
  profitTranslator.onNext = fix2;
#+END_SRC
#+NAME: fix2
#+BEGIN_SRC js
// Helper function for translator:  convert number to string
function fix2( n ) {
  this.sendNext( n.toFixed( 2 ) );
}
#+END_SRC

** Connections

Once we have created an adapter and translator, all that is left is to connect
them by subscribing observers to observables.  To support values going from
the View to the View-Model, the translator subscribes to the adapter, and the
variable subscribes to the translator.  To support values going from the
View-Model to the View, the adapter subscribes directly to the variable.

#+NAME: connections
#+BEGIN_SRC js
  // Connect observables to observers
  incomeAdapter.addObserver( incomeTranslator );
  incomeTranslator.addObserver( context.income );
  context.income.addObserver( incomeAdapter );
#+END_SRC

At this point, the variable is bound to the View.  Any changes to the variable
will go directly to the View.  Any changes to the View will first go through
the translator, then to the variable.

Note that it is /not/ possible to reuse translators.  If you were to try, you
would have to subscribe the same translator to two view adapters, and two
variables to the same translator.  This would mean that every time either view
adapter sent a value, /both/ variables would receive the value.  Thus, e.g.,
we must create a second string-to-number translator for the =expenses=
variable; we cannot reuse the one for =income=.

* The ~bind~ function and binding descriptions

The code required to connect adapters, translators, and variables tends to be
somewhat repetitive.  To help avoid boilerplate code, HotDrink provides the
~bind~ function which can make these connections for you.

** The example

This example also contains a single constraint.  This time the constraint
represents the mathematical equation $subtotal*(1+tax/100)=total$.  As with
previous examples, updating the text box will cause the result to update
automatically.

This example performs all binding using the ~bind~ function with built-in
adapters and translators.

#+HTML: <div class="results">
#+INCLUDE: tangle/description.html html
#+HTML: </div>
#+HTML: <script type="text/javascript">
#+HTML: (function() {
#+INCLUDE: tangle/description.js html
#+HTML: })();
#+HTML: </script>

*Source Code*

#+CAPTION: /View/ (show/hide)
#+BEGIN_SRC html -n :exports code :tangle tangle/description.html :padline no
<table>
  <style type="text/css" scoped>
    th { padding-right: 1ex; text-align: left; font-weight: bold; }
  </style>
  <tr>
    <th>Subtotal:</th>
    <td><input type="text" id="subtotalEdit"/></td>
  </tr>
  <tr>
    <th>Tax:</th>
    <td><input type="text" id="taxEdit"/>%</td>
  </tr>
  <tr>
    <th>Total:</th>
    <td>$<span id="totalSpan"></span></td>
  </tr>
</table>
#+END_SRC

#+CAPTION: /View-Model/ (show/hide)
#+BEGIN_SRC js -n :exports code :tangle tangle/description.js :padline no
// Define the context
var context = new hd.ContextBuilder()
    .v( 'subtotal', 39.99 )
    .v( 'tax', 8 )
    .v( 'total' )

    .c( 'subtotal, tax, total' )
    .m( 'subtotal, tax -> total',
        function( subtotal, tax ) {
          return Math.round( subtotal * (100+tax) ) / 100;
        } )

    .context();

// Create the constraint system
var pm = new hd.PropertyModel();
pm.addComponent( context );
#+END_SRC

#+CAPTION: /Binding/ (show/hide)
#+BEGIN_SRC js -n :exports code :tangle tangle/description.js :padline no :noweb yes
window.addEventListener( 'load', function() {
<<binding-description>>
  hd.bind( {view:    new hd.Edit( document.getElementById( 'taxEdit' ) ),
            model:   context.tax,
            toModel: [hd.toNum(), hd.round( 0 )],
            toView:  hd.fix( 0 )
           }
         );
  hd.bind( {view:    new hd.Text( document.getElementById( 'totalSpan' ) ),
            model:   context.total,
            toModel: hd.fix( 2 )
           }
         );
} );
#+END_SRC

** Translator factories

Just as HotDrink provides several common adapter types, so too it provides
several common translator types.  While it is possible to create instances of
these types yourself using the =new= operator, HotDrink provides factory
functions for creating new instances of these translator types.  We describe
these functions in detail in the [[file:binding.org][Advanced Binding Concepts]] how-to.  For now,
however, we introduce three translators for use in the remainder of this
how-to.

The ~hd.toNum~ factory function creates a translator that converts a string to
a number, just like the translators created in the previous example.

#+BEGIN_SRC js
  // Using built-in translator
  var toNumTranslator = hd.toNum();
#+END_SRC

The ~hd.fix~ factory function creates a translator that converts a number to a
string.  This factory function takes a parameter indicating how many digits
should be present after the decimal point.

#+BEGIN_SRC js
  // Using built-in translator
  var fix2Translator = hd.fix( 2 );
#+END_SRC

Note that using a ~hd.fix~ translator only modifies how the value is /seen/ by
the View; it does not change the value in the View-Model.  For example, if a
variable was connected to an ~Edit~ adapter using the above translator, the
user could enter as many digits of precision as he desired; the extra digits
would be stored in the View-Model, but would not be displayed by the View.

We can improve this scheme by changing the value which is given to the
View-Model using the ~hd.round~ translator.  This translator takes a number
and rounds it to a certain number of digits of precision.

#+BEGIN_SRC js
  // A rounding translator
  var roundTranslator = hd.round( 2 );
#+END_SRC

Note that this translator does /not/ change the data-type of a value; instead
it modifies the value.  If a change in data-type is required, this translator
can be used in conjunction with another, such as ~hd.toNum~.  We demonstrate
this below.


** Binding descriptions

The function ~hd.bind~ takes a single parameter: an object referred to as the
/binding description/.  A binding description is any object which has the
following four properties:

- ~view~ :: observable/observer representing a value of the View
- ~model~ :: observable/observer representing a value of the View-Model
- ~toView~ :: translator(s) for going from View-Model to View
- ~toModel~ :: translator(s) for going from View to View-Model

The ~toView~ and ~toModel~ properties are optional; the only required
properties are ~view~ and ~model~.  If present, the ~toView~ and ~toModel~
properties should hold either a single translator, or an array of
translators.  Consider, for example, the binding description in the following
call to ~hd.bind~.

#+NAME: binding-description
#+BEGIN_SRC js
  hd.bind( {view:    new hd.Edit( document.getElementById( 'subtotalEdit' ) ),
            model:   context.subtotal,
            toModel: [hd.toNum(), hd.round( 2 )],
            toView:  hd.fix( 2 )
           }
         );
#+END_SRC

Here, the /view/ object is an ~Edit~ view adapter, and the /model/ object is
the =subtotal= variable.  When going from the View to the View-Model, we first
translate the string to a number, then round the number to two digits.  Going
the other way, we convert the number to a fixed-point string with two digits
of precision.

* Multi-way constraints

Constraints in HotDrink can be solved in multiple directions.  For example,
given the constraint $width=right-left$, we could solve for any one of the
three variables using the values of the other two.  To create a multi-way
constraint, we simply provide one method for each way the constraint can be
solved.

In general, HotDrink tries to preserve the values the user has entered most
recently.  Thus, when given a choice of how to solve a constraint, HotDrink
will look for the method which updates the /least/ recently edited variable.

** The example

This example defines a rectangular region of an image.  There are several
interrelated values reflected by this region, such as its boundaries, its
dimensions, and its aspect ratio (ration of wight to height).  Editing any of
these values will update others so that they are all consistent.

#+HTML: <div class="results">
#+INCLUDE: tangle/multi-constraint.html html
#+HTML: </div>
#+HTML: <script type="text/javascript">
#+HTML: (function() {
#+INCLUDE: tangle/multi-constraint.js html
#+HTML: })();
#+HTML: </script>

*Source Code*

#+CAPTION: /View/ (show/hide)
#+BEGIN_SRC html -n :exports code :tangle tangle/multi-constraint.html :padline no
<table style="text-align: right">
  <tr>
    <td>
      Left:  <input type="text" id="left"/><br/>
      Right: <input type="text" id="right"/><br/>
      Width: <input type="text" id="width"/><br/>
    </td>
    <td>
      Top:    <input type="text" id="top"/><br/>
      Bottom: <input type="text" id="bottom"/><br/>
      Height: <input type="text" id="height"/><br/>
    </td>
  </tr>
  <tr>
    <td colspan="2" style="text-align:center">
      Aspect Ratio: <input type="text" id="aspect"/>
    </td>
  </tr>
</table>
#+END_SRC

#+CAPTION: /View-Model/ (show/hide)
#+BEGIN_SRC js -n :exports code :tangle tangle/multi-constraint.js :padline no :noweb yes
// Helper functions
function sum ( x, y ) { return x + y; }
function diff( x, y ) { return x - y; }
function prod( x, y ) { return x * y; }
function quot( x, y ) { return x / y; }

var context = new hd.ContextBuilder()
<<variables>>

  // Constraint: width == right - left
  .c( 'left, right, width' )
  .m( 'left, width -> right', sum  )
  .m( 'right, left -> width', diff )
  .m( 'right, width -> left', diff )

  // Constraint: height == bottom - top
  .c( 'top, bottom, height' )
  .m( 'top, height -> bottom', sum  )
  .m( 'bottom, top -> height', diff )
  .m( 'bottom, height -> top', diff )

  // Constraint: aspect == width / height
  .c( 'width, height, aspect' )
  .m( 'height, aspect -> width', prod )
  .m( 'width, height -> aspect', quot )
  .m( 'width, aspect -> height', quot )

  .context();

var pm = new hd.PropertyModel();
pm.addComponent( context );
#+END_SRC

#+CAPTION: /Binding/ (show/hide)
#+BEGIN_SRC js -n :exports code :tangle tangle/multi-constraint.js :padline no
window.addEventListener( 'load', function() {
  hd.bind( {view:    new hd.Edit( document.getElementById( 'left' ) ),
            model:   context.left,
            toModel: hd.toNum()
           }
         );
  hd.bind( {view:    new hd.Edit( document.getElementById( 'right' ) ),
            model:   context.right,
            toModel: hd.toNum()
           }
         );
  hd.bind( {view:    new hd.Edit( document.getElementById( 'width' ) ),
            model:   context.width,
            toModel: hd.toNum()
           }
         );
  hd.bind( {view:    new hd.Edit( document.getElementById( 'top' ) ),
            model:   context.top,
            toModel: hd.toNum()
           }
         );
  hd.bind( {view:    new hd.Edit( document.getElementById( 'bottom' ) ),
            model:   context.bottom,
            toModel: hd.toNum()
           }
         );
  hd.bind( {view:    new hd.Edit( document.getElementById( 'height' ) ),
            model:   context.height,
            toModel: hd.toNum()
           }
         );
  hd.bind( {view:    new hd.Edit( document.getElementById( 'aspect' ) ),
            model:   context.aspect,
            toModel: hd.toNum()
           }
         );
} );
#+END_SRC


** Updating the constraint system

Whenever you modify any of the variables of the property model, HotDrink
assumes any constraints which use those variables are no longer satisfied.  It
then performs two tasks.  The first is to decide which variable (or variables)
should be updated.  The second is to use a method (or methods) you provided to
calculate a new value for that variable (or variables).

Deciding which variables to update is not a trivial task.  Consider the
following scenario:  the variable ~left~ is modified, so HotDrink decides to
update the ~width~ variable so that ~width == right - left~.  But now the
constraint ~aspect == width / height~ is no longer satisfied, so HotDrink must
update one of those variables as well.  Thus, the effects of a single edit can
cascade to multiple variables.  HotDrink must consider the entire constraint
system and decide which variables will be used to update which other
variables.  This plan for updating is called a /dataflow/.

Often there is more than one possible dataflow which could work.  In this
case, HotDrink will /generally/ select the dataflow which preserves variables
that have been more recently edited by the user.  (In certain unusual cases
the behavior is slightly more complicated, but this rule of thumb is close
enough for now.)  We believe this is generally what the user wants, as the
values more recently edited are more likely to reflect the user's current
intent.

** Declaring multiple variables at once

This example uses the ~variables~ function of the context builder to declare
multiple variables at once.  This function takes two parameters.  The first is
a string containing a comma-delimited list of variables to create.  The second
is an object used as a map to provide initial values for variables.  If a
variable does not contain an entry in the map, it is treated as uninitialized,
and therefore given the value ~undefined~.

#+NAME: variables
#+BEGIN_SRC js
  .variables( 'left, right, width, top, bottom, height, aspect',
              {left: 0, right: 100, top: 60, bottom: 140}
  )
#+END_SRC

Note that the variables are created in the order in which they appear in the
string.  This is significant as the order in which variables are created
determines the initial editing order for the variables, and thus affects the
initial dataflow selected by the system.  Initializing a variable is treated
as an edit; creating an uninitialized variable is not treated as an edit.
Thus, the system will initially pick a dataflow that writes to uninitialized
variables; If any initialized variables need to be overwritten, the system
will choose to overwrite the variables created /earlier/, since those will be
considered less-recently edited.

The ~variables~ member function returns the builder.  The abbreviation for
~variables~ is ~vs~; we will use this abbreviation in the remainder of the
examples.

** Reusing functions

Notice that we can reuse the same function for multiple methods.  In this
example, we defined four simple mathematical functions at the top, then simply
used the appropriate function for each method.  Again, the values passed as
arguments will come from the variables specified in the signature.

In fact, if your constraints really are trivial equations such as this, there
is an even easier way to specify them.  We'll discuss that in the section
"[[* Shortcut: equations][Shortcut: equations]]".

* Input/output variables

When solving the constraint system, HotDrink must ensure that any variables
needing to be updated are given a new value before they are read by any
methods.  This creates a challenge for methods that want to look at the old
value of a variable as they update it.  Fortunately, HotDrink has a method of
providing the previous value of a variable to a method.

** The example

The constraint here is actually an inequality: $begin\le{}end+1$.  If you set one
variable so that the inequality holds, then the other variable is not
modified.  However, if you make the inequality false, then the other variable
is changed just enough to make it true.

#+HTML: <div class="results">
#+INCLUDE: tangle/io-param.html html
#+HTML: </div>
#+HTML: <script type="text/javascript">
#+HTML: (function() {
#+INCLUDE: tangle/io-param.js html
#+HTML: })();
#+HTML: </script>

*Source Code*

#+CAPTION: /View/ (show/hide)
#+BEGIN_SRC html -n :exports code :tangle tangle/io-param.html :padline no
<div style="display:inline-block; text-align:right">
  Begin: <input type="text" id="begin"/><br/>
  End:   <input type="text" id="end"/>
</div>
#+END_SRC

#+CAPTION: /View-Model/ (show/hide)
#+BEGIN_SRC js -n :exports code :tangle tangle/io-param.js :padline no :noweb yes
var context = new hd.ContextBuilder()
  .v( 'begin', 10 ).v( 'end', 20 )

   // Constraint: begin < end
  .c( 'begin, end' )
<<previous>>
  .m( '!begin, end -> begin',
      function( begin, end ) {
        return begin > end - 1 ? end - 1 : begin;
      } )

  .context();

var pm = new hd.PropertyModel;
pm.addComponent( context );
#+END_SRC

#+CAPTION: /Binding/ (show/hide)
#+BEGIN_SRC js -n :exports code :tangle tangle/io-param.js :padline no
window.addEventListener( 'load', function() {
  hd.bind( {view:    new hd.Edit( document.getElementById( 'begin' ) ),
            model:   context.begin,
            toModel: hd.toNum()
           }
         );
  hd.bind( {view:    new hd.Edit( document.getElementById( 'end' ) ),
            model:   context.end,
            toModel: hd.toNum()
           }
         );
} );
#+END_SRC

#+HTML: <div class="notes">
#+HTML: </div>

** Previous variable values

Technically a method cannot use the same variable as input and output: it
would require the method to produce its output before it read its parameters.
However, we allow a method to access the /previous/ value of a variable---the
value it had before we began solving the constraint system.

In fact, a method may access the previous value of /any/ variable, not just
its outputs.  For this reason, when a method wants the previous value of a
variable as an input, we require that it be indicated in the method's
signature.  This is done by putting an exclamation point ("!") in front of the
variable name.  For example, the following method uses the previous value of
~begin~ and the updated value of ~end~ to calculate the updated value of
~begin~.

#+NAME: previous
#+BEGIN_SRC js
  .m( 'begin, !end -> end',
      function( begin, end ) {
        return end < begin + 1 ? begin + 1 : end;
      } )
#+END_SRC

** Caveat

In general, it is unwise to make assumptions about when HotDrink will run your
method, including how often your method will be run.  Thus, you should avoid
methods like the following.

#+BEGIN_SRC js
.m( "!n, x -> n",
    function( n ) {
      return n + x;
    } )
#+END_SRC

Such a method may lead to poorly defined behavior, since its effect depends on
how frequently it is run.  Furthermore, it is unclear what constraint such a
method enforces; the relation $n=n+x$ seems nonsensical.

If you need some sort of incremental behavior, it is better to use a separate
variable to represent the increment since the previous iteration.  For
example, one might use a variable $t$ to represent time.  Then we could write
the method as follows:

#+BEGIN_SRC js
.method( "!t, t, !n, x -> n", function( t1, t2, n, x ) {
  return n + (t2 - t1)*x;
}
#+END_SRC

Such a method would define $n$ as the integral of $x$ over $t$.  Each change
in $t$ would cause the method to update the value of $n$ accordingly.

* Multiple output variables

In many cases it is desirable to have a method with multiple output variables.
Of course, a function can only return a single value; however, we allow that
value to be an array.  The different elements of that array can then be
assigned to variables by pattern matching against the signature.

** The example

This is a straightforward constraint: the value for the year is the sum of the
values for the four quarters.  However, data can only flow two ways in this
constraint.  If any one of the quarters is modified, then the year is updated.
If the year is modified, then we take the difference and distribute it evenly
among the four quarters, thus satisfying the constraint.

#+HTML: <div class="results">
#+INCLUDE: tangle/multi-out.html html
#+HTML: </div>
#+HTML: <script type="text/javascript">
#+HTML: (function() {
#+INCLUDE: tangle/multi-out.js html
#+HTML: })();
#+HTML: </script>

*Source Code*

#+CAPTION: /View/ (show/hide)
#+BEGIN_SRC html -n :exports code :tangle tangle/multi-out.html :padline no
<div style="display:inline-block; text-align:right">
  First Quarter:  <input type="text" id="q1"/><br/>
  Second Quarter: <input type="text" id="q2"/><br/>
  Third Quarter:  <input type="text" id="q3"/><br/>
  Fourth Quarter: <input type="text" id="q4"/><br/>
  <hr/>
  Full Year:      <input type="text" id="year"/><br/>
</div>
#+END_SRC

#+CAPTION: /View/ (show/hide)
#+BEGIN_SRC js -n :exports code :tangle tangle/multi-out.js :padline no :noweb yes
var context = new hd.ContextBuilder()
  .vs( 'q1, q2, q3, q4, year', {q1: 10, q2: 30, q3: 60, q4: 100} )

  .c( 'q1, q2, q3, q4, year' )
<<multiout>>

  .context();

var pm = new hd.PropertyModel();
pm.addComponent( context );
#+END_SRC

#+CAPTION: /Binding/ (show/hide)
#+BEGIN_SRC js -n :exports code :tangle tangle/multi-out.js :padline no
window.addEventListener( 'load', function() {
  hd.bind( {view:    new hd.Edit( document.getElementById( 'q1' ) ),
            model:   context.q1,
            toModel: hd.toNum()
           }
         );
  hd.bind( {view:    new hd.Edit( document.getElementById( 'q2' ) ),
            model:   context.q2,
            toModel: hd.toNum()
           }
         );
  hd.bind( {view:    new hd.Edit( document.getElementById( 'q3' ) ),
            model:   context.q3,
            toModel: hd.toNum()
           }
         );
  hd.bind( {view:    new hd.Edit( document.getElementById( 'q4' ) ),
            model:   context.q4,
            toModel: hd.toNum()
           }
         );
  hd.bind( {view:    new hd.Edit( document.getElementById( 'year' ) ),
            model:   context.year,
            toModel: hd.toNum()
           }
         );
} );
#+END_SRC

** Multiple return values

The signature of the following method designates that it will return an array,
and that the elements of that array are the values of =q1=, =q2=, =q3=, and
=q4= respectively.  When the value is returned, it is matched against the
signature, and values are assigned to the corresponding variables.

#+NAME: multiout
#+BEGIN_SRC js
  .m( 'year, !q1, !q2, !q3, !q4 -> q1, q2, q3, q4',
      function( year, q1, q2, q3, q4 ) {
        var diff = (year - q1 - q2 - q3 - q4) / 4;
        return [q1 + diff, q2 + diff, q3 + diff, q4 + diff ];
      }
  )
#+END_SRC

Note that this form of pattern matching works for inputs as well.  For
example, we could indicate that we wanted to receive the old values of =p1=,
=p2=, =p3=, and =p4= as an array, like so.

#+BEGIN_SRC js
  .m( 'year, [!q1, !q2, !q3, !q4] -> [q1, q2, q3, q4]',
      function( year, qs ) {
        var diff = (year - qs[0] - qs[1] - qs[2] - qs[3]) / 4;
        return qs.map( function( qi ) { return qi + diff; }
      }
  )
#+END_SRC

* Declarative binding

We return to the topic of binding, this time to see how we may embed binding
specifications into tags.  Doing so allows us to iterate over the DOM and
automatically perform any bindings we encounter.

** The example

This example uses no constraints; it simply illustrates a new binding
technique.  Editing the text boxes modifies the value displayed to the right.

#+HTML: <div class="results">
#+INCLUDE: tangle/decl-bind.html html
#+HTML: </div>
#+HTML: <script type="text/javascript">
#+HTML: (function() {
#+INCLUDE: tangle/decl-bind.js html
#+HTML: })();
#+HTML: </script>

*Source code*

#+CAPTION: /View/ (show/hide)
#+BEGIN_SRC html -n :exports code :tangle tangle/decl-bind.html :padline no :noweb yes
<div id="ex6">
<<data-bind>>
           &rArr; <span data-bind="{mkview: hd.Text, model: x}"></span><br/>
  Y: <input type="text" data-bind="{mkview: hd.Edit, model: y, toModel: hd.toNum()}"/>
           &rArr; <span data-bind="{mkview: hd.Text, model: y}"></span>
</div>
#+END_SRC

#+CAPTION: /View-Model/ (show/hide)
#+BEGIN_SRC js -n :exports code :tangle tangle/decl-bind.js :padline no
var context = new hd.ContextBuilder()
    .v( 'x', 'Hello, again!' ).v( 'y', 3 ).context();

var pm = new hd.PropertyModel();
pm.addComponent( context );
#+END_SRC

#+CAPTION: /Binding/ (show/hide)
#+BEGIN_SRC js -n :exports code :tangle tangle/decl-bind.js :padline no :noweb yes
window.addEventListener( 'load', function() {
<<bind>>
} );
#+END_SRC

** Automatic binding function

By now you've probably noticed that the binding section tends to be repetitive
and boring.  HotDrink offers two shortcuts to help alleviate this.  The first,
shown here, is allowing binding specifications to be embedded in the HTML.
There are two steps required for this.

*** Add binding specifications

The first step is to add markup in the HTML to describe how elements should be
bound.  To indicate that you wish to bind a variable to the node for an HTML
tag, simply add a ~data-bind~ attribute to the tag with the code for the
binding specification.  At run-time, HotDrink will evaluate this attribute
string as JavaScript code to take the result as the binding specification
object.

#+NAME: data-bind
#+BEGIN_SRC js
  X: <input type="text" data-bind="{mkview: hd.Edit, model: x}"/>
#+END_SRC

Note, however, one slight change to this binding specification.  In previous
examples our view object was a view adapter which encapsulated some DOM node
in the tree.  When you embed a binding specification in the HTML, HotDrink
assumes that a view adapter needs to be created for the DOM node.  Thus, it
looks for an attribute named "~mkview~".  This should be a constructor or
factory function which takes a single DOM node parameter.  HotDrink will use
this constructor or factory to create the view object, like so.

#+BEGIN_SRC js
specification.view = new specification.mkview( domNode );
#+END_SRC

Also notice that, in the binding specification, you may refer to the variable
by it's name in the model.  For example, above we simply wrote ~model: x~
instead of ~model: context.x~.  When evaluating your binding specification,
HotDrink will first try to find any names in the context you provided to the
binding function (see below); if it cannot find it in the context, it will
treat the name as a global identifier.

*** Call the binding function

The second step is to call the HotDrink function to performs the binding.  You
can do this as follows.

#+NAME: bind
#+BEGIN_SRC js
  hd.performDeclaredBindings( context, document.getElementById( 'ex6' ) );
#+END_SRC

This function takes two parameters: a model to use, and a DOM node at which to
start searching.  This function will search the DOM node passed to it and any
DOM nodes under it for elements with a ~data-bind~ attribute.  When it finds
one, it evaluate the binding specification as described above and then pass it
to ~hd.bind~.

In the example above, HotDrink would examine all tags contained by the ~<div>~
tag which has the id ="ex6"=.  It would evaluate the binding specifications
for each of the four tags with ~data-bind~ attributes.  Then it will attempt
to bind according to each of those specifications.

The second parameter is optional; it defaults to ~document.body~ so that the
entire document will be searched.  Note, however, that this could cause
problems if you are binding different models to different parts of the
document (for example, as we are in this document).

As with manual binding, you must ensure that the nodes involved have been
added to the DOM /before/ calling ~performDeclaredBindings~; therefore, it is
advised to use the ~window.onload~ event or some alternative method of
executing code after the DOM is fully ready.

* Shortcut: binding specification factories

The binding specifications in a ~data-bind~ attribute are evaluated as JavaScript
code.  This means it can contain any JavaScript code which produces a binding
object.  Thus, HotDrink provides several factory functions that create common
binding specifications.

** The example

This is the same as the previous example, except the binding specification
objects are created using factory functions.

#+HTML: <div class="results">
#+INCLUDE: tangle/fact-bind.html html
#+HTML: </div>
#+HTML: <script type="text/javascript">
#+HTML: (function() {
#+INCLUDE: tangle/fact-bind.js html
#+HTML: })()
#+HTML: </script>

#+CAPTION: /View/ (show/hide)
#+BEGIN_SRC html -n :exports code :tangle tangle/fact-bind.html :padline no
<div id="ex7">
  X: <input type="text" data-bind="hd.edit( x )"/>
           &rArr; <span data-bind="hd.text( x )"></span><br/>
  Y: <input type="text" data-bind="hd.num( y )"/>
           &rArr; <span data-bind="hd.text( y )"></span>
</div>
#+END_SRC

#+CAPTION: /View-Model/ (show/hide)
#+BEGIN_SRC js -n :exports code :tangle tangle/fact-bind.js :padline no
var context = new hd.ContextBuilder()
    .v( 'x', 'Hello, again!' ).v( 'y', 3 ).context();

var pm = new hd.PropertyModel();
pm.addComponent( context );
#+END_SRC

#+CAPTION: /Binding/ (show/hide)
#+BEGIN_SRC js -n :exports code :tangle tangle/fact-bind.js :padline no
window.addEventListener( 'load', function() {
  hd.performDeclaredBindings( context, document.getElementById( 'ex7' ) );
} );
#+END_SRC


** Factory functions

Binding specification objects tend to be lengthy and follow the same basic
patterns.  Since the ~data-bind~ attribute is simply evaluated as JavaScript
code, we can use any JavaScript code we want to create these objects---e.g.,
call a factory function to create the object for us.

HotDrink provides several factory functions for creating these objects.  There
is nothing special about these factory functions, and you are encouraged to
make your own.  For example, the function ~hd.edit~ looks basically like the
following:

#+BEGIN_SRC js
hd.edit = function( model, toView, toModel ) {
  return {mkview:  hd.Edit,
          model:   model,
          toView:  toView,
          toModel: toModel
         };
}
#+END_SRC

A full list of the factory functions can be found in the [[file:binding.org][Advanced Binding
Concepts]] how-to, but for now we point out the following three:

1. The ~hd.edit~ factory creates the binding specification for a text edit
   box.
2. The ~hd.num~ factory also creates a specification for a text edit box,
   but the value is converted to a number before passing it to the model.
   Note that this factory takes a second optional argument which is used to
   specify the number of digits after the decimal point.
3. The ~hd.text~ factory creates the binding specification for replacing the
   contents of a tag with the value of a variable.

* Shortcut: equations

HotDrink does not inherently know how to solve any type of constraint; it
relies on the programmer to provide constraint satisfaction methods.  That
being said, because many constraints can be represented as very simple
mathematical equations, HotDrink includes a very basic equation parser which
can translate simple equations into a set of constraint satisfaction methods.
You are welcome to use this parser to avoid writing certain types of trivial
methods.

** The example

In this example we can calculate the minimum payment required on an account
balance based on a given percentage of the balance.  We can also specify the
actual payment made, though it must be higher than the minimum.

#+HTML: <div class="results">
#+INCLUDE: tangle/eq.html html
#+HTML: </div>
#+HTML: <script type="text/javascript">
#+HTML: (function() {
#+INCLUDE: tangle/eq.js html
#+HTML: })();
#+HTML: </script>

#+BEGIN_SRC html -n :exports code :tangle tangle/eq.html :padline no
<table style="text-align: right" id="ex8">
  <tr><td>
    Account Balance: <input type="text" data-bind="hd.num( balance, 2 )"/><br/>
    Minimum Percentage: <input type="text" data-bind="hd.num( min_rate, 3 )"/><br/>
    Minimum Payment: <input type="text" data-bind="hd.num( min_pay, 2 )"/><br/>
    <hr/>
    Payment Made: <input type="text" data-bind="hd.num( pay, 2 )"/>
  </td></tr>
</table>
#+END_SRC

#+BEGIN_SRC js -n :exports code :tangle tangle/eq.js :padline no
var context = new hd.ContextBuilder()
  .vs( 'balance, min_rate, min_pay, pay', {balance: 4000, min_rate: 6.125} )
  .equation( "min_pay == balance * min_rate / 100" )
  .equation( "pay >= min_pay" )
  .context();

var pm = new hd.PropertyModel();
pm.addComponent( context );

window.addEventListener( 'load', function() {
  hd.performDeclaredBindings( context, document.getElementById( 'ex8' ) );
} );
#+END_SRC

** Allowable equations

HotDrink is /not/ a program for solving mathematical equations.  However,
simple equations like the ones in this example are common and are not hard to
solve.  Therefore, as a convenience, HotDrink provides this shortcut method
for creating constraints from /simple/ equations.

The equations which HotDrink can enforce are those in which (1) no variable
appears in the equation more than once, and (2) the only operations are add
(~+~), subtract (~-~), multiply (~*~), and divide (~/~).  This means, e.g., no
exponents, no square roots, etc.

Note that, despite the name, the ~equation~ member function can also parse
inequalities.  Thus, the allowable comparison operators in an equation are
~==~, ~<=~, and ~>=~.

Examples of valid equations:

- ~width == right - left~
- ~aspect == width / height~
- ~surface == (2*width + 2*length) * height~

Examples of invalid equations:

- ~perimeter = width + height + width + height~
- ~area == 3.14*radius^2~
- ~side == sqrt(area)~

** Implementation

HotDrink implements these equations by parsing them and then, for each
variable, constructing a function which solves for that variable.  Each of
these functions then becomes a method.  Thus, the constraint will have as many
methods as there are variables, with each method updating exactly one
variable.

To be clear, the ~equation~ function's only advantage is that it saves you
some typing; in the end you still get a normal constraint, the same as if you
had written the methods yourself.

As you probably expect by now, the ~equation~ member function returns the
builder.  It can be abbreviated ~eq~.

#  LocalWords:  HotDrink observables multi
