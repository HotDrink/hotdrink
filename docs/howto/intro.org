#+TITLE: Introduction to HotDrink
#+LANGUAGE:  en
#+OPTIONS: H:2 author:nil creator:nil toc:nil
#+HTML_LINK_HOME: http://hotdrink.github.io/hotdrink/
#+HTML_LINK_UP: file:index.html
#+HTML_HEAD_EXTRA: <script type="text/javascript" src="../../scripts/hotdrink.js"></script>
#+HTML_HEAD_EXTRA: <script type="text/javascript" src="collapse.js"></script>
#+HTML_HEAD_EXTRA: <link rel="stylesheet" type="text/css" href="style.css"/>
#+INCLUDE: setup.org
#+MACRO: scraplink [[$1][~<<$1>>~]]

* Overview of basic concepts

HotDrink is a JavaScript library for implementing GUIs declaratively.
With HotDrink, the programmer specifies relationships (as sets of
functions) between pieces of data in the GUI, instead of event
handlers that control what should happen and when. HotDrink decides
when to enforce which relationships.

** Constraint systems

At the heart of a ``HotDrink-powered'' application is a /dataflow
constraint system/.  A constraint system consists of /variables/ and
/constraints/, where each constraint represents a relation over some
of the variables.  For example, given three variables, $A$, $w$, and
$h$ (for area, width, and height of a rectangle), a constraint could
represent the relation $A = w h$.  Given one more variable $p$ (for
perimeter), another constraint could represent the relation $p = w +
h$. To ease the discussion, we name this example constraint system of
four variables and two constraints as the /whap/ system.

HotDrink uses the whap system to manage the GUI below.
If a user edits any of the GUI's fields, HotDrink will 
recompute values of some of the other fields to enforce
the /whap/ system's constraints.

#+HTML: <div class="whap-gui">
{{{include-html("tangle/intro.html")}}}
#+HTML: </div>
#+HTML: <script type="text/javascript">
#+HTML: (function() {
{{{include-html("tangle/intro.js")}}}
#+HTML: })();
#+HTML: </script>

In HotDrink, constraints between variables are expressed as sets of
functions.  These functions are called /methods/ (short for
/constraint satisfaction methods/). Each method computes new values
for some of its constraint's variables, so that the constraint is
enforced (the relation it represents becomes true).  It is up to the
programmer to decide how to break the relation into
functions [fn:1]. In modeling the /whap/ system, we chose to represent
the first constraint with three methods ($m_1 = p \leftarrow 2 (w+h)$,
$m_2 = h \leftarrow p/2 - w$, and $m_3 = w \leftarrow p/2 - h$) and
the second constraint with two methods ($n_1 = A \leftarrow wh$ and
$n_2 = (w, h) \leftarrow (\sqrt A, \sqrt A)$).

A constraint system can be viewed as a graph where variables and
methods are nodes and edges indicate methods' input and output
variables. Figure [[fig:whap-graph]] shows the graph of the /whap/ system.

#+begin_src dot :file area-w-h-perimeter.png :cmd neato :cmdline -Kdot -Tpng 
  digraph whap {
    rankdir=LR; ranksep=1;
    node [shape=box]; A; w; h; p;
    node [shape=circle,fixedsize=true,width=0.3,label=""]; 
    A2wh [label="n1"]; wh2A [label="n2"]; ph2w [label="m3"]; pw2h [label="m2"]; wh2p [label="m1"];

   { rank=same; A }
   { rank=same; A2wh; wh2A }
   { rank=same; w; h }
   { rank=same; ph2w; pw2h }
   { rank=same; wh2p }
   { rank=same; p }

    A -> A2wh [style=dotted];
    A2wh -> {w h};

    w -> wh2A [style=dotted]; 
    h -> wh2A [style=dotted]; 
    wh2A -> A;

    w -> wh2p [style=dotted];
    h -> wh2p [style=dotted];
    wh2p -> p;

    p -> pw2h [style=dotted, constraint=false];
    w -> pw2h [style=dotted];
    pw2h -> h [constraint=false];

    p -> ph2w [style=dotted, constraint=false];
    h -> ph2w [style=dotted];
    ph2w -> w [constraint=false];

    overlap=false
    fontsize=12;
  }
#+end_src

#+CAPTION: A multi-way dataflow constraint system on variables $A$, $w$, $h$, and $p$. For better readability, methods' inputs are marked with dashed and outputs with solid edges.
#+LABEL: fig:whap-graph
#+RESULTS:
[[file:area-w-h-perimeter.png]]

With HotDrink's syntax, the /whap/ constraint system could be specified
as follows.  Note that this tutorial names some of
the source blocks with the syntax @@html:<span
class="org-src-name">source-block-name</span>@@ .  Using such a
reference within another source block indicates that the contents of
the named source block should be expanded at the location of the
reference.

#+CAPTION: whap-component
#+NAME: whap-component
#+BEGIN_SRC javascript
var cb = new hd.ComponentBuilder();
var whap = cb.variables('p, w, h, A', { A: 100 })
  .constraint( 'p, w, h' )
    .method( 'w, h -> p', (w, h) => 2*(w + h) )
    .method( 'p, w -> h', (p, w) => p/2 - w )
    .method( 'p, h -> w', (p, h) => p/2 - h )
  .constraint( 'A, w, h' )
    .method( 'w, h -> A', (w, h) => w * h )
    .method( 'A -> w, h', (A) => [ Math.sqrt(A), Math.sqrt(A) ] )
  .component();
#+END_SRC

The ~variables~ method declares the variables of the system and and
the ~constraint~ method those of a constraint. Each call to ~method~
defines one method of a constraint.  The first argument to ~method~ is
a string that specifies the input and output variables of a method,
the second is the code of the method, here defined using the arrow
function syntax. The method ~A -> w, h~ returns an array (of two
elements), because it has two output variables.

In a HotDrink-powered user interface, GUI events are translated to
requests to modify a constraint system's variables.  Modifications
result in constraints that are no longer satisfied.  HotDrink responds
by /solving/ the constraint system: it determines which methods need
to be executed and in which order, and executes them to re-enforce all
potentially violated constraints. HotDrink notifies if a variable's
value changes as the result of solving, so that views can be updated.

Concretely, solving involves selecting one method from each constraint
such that the selected methods form a directed acyclic graph (DAG) in
the constraint system graph. This graph defines a /dataflow/: which
variables are used to update which other variables.  HotDrink's
constraint system is a /multi-way dataflow constraint system/: there
may be many dataflows that could solve the system. As a coarse
approximation, HotDrink selects a dataflow that preserves the values
of variables that a user has changed most recently. Table
[[fig:whap-dataflows]] shows all four possible dataflows of the /whap/
system.

#+NAME: awh-flow-1
#+begin_src dot :file area-w-h-perimeter-flow-1.png :cmd neato :cmdline -Kdot -Tpng :results none
  digraph whap {
    size="3,2";
    rankdir=LR; ranksep=1;
    node [shape=box]; A; w; h; p;
    node [shape=circle,fixedsize=true,width=0.2,label=""]; 
    A2wh; wh2A [color=lightgray]; ph2w [color=lightgray]; pw2h [color=lightgray]; wh2p;

   { rank=same; A }
   { rank=same; A2wh; wh2A }
   { rank=same; w; h }
   { rank=same; ph2w; pw2h }
   { rank=same; wh2p }
   { rank=same; p }

    A -> A2wh [style=solid];
    A2wh -> {w h};

    w -> wh2A [style=solid, color=lightgrey]; 
    h -> wh2A [style=solid, color=lightgrey]; 
    wh2A -> A [color=lightgrey];

    w -> wh2p;
    h -> wh2p;
    wh2p -> p;

    edge [color=lightgrey];
    p -> pw2h [style=solid,constraint=false];
    w -> pw2h [style=solid];
    pw2h -> h [constraint=false];

    p -> ph2w [style=solid,constraint=false];
    h -> ph2w [style=solid];
    ph2w -> w [constraint=false];

    overlap=false
    fontsize=12;
  }
#+end_src

#+NAME: awh-flow-2
#+begin_src dot :file area-w-h-perimeter-flow-2.png :cmd neato :cmdline -Kdot -Tpng :results none
  digraph whap {
    size="3,2";
    rankdir=LR; ranksep=1;
    node [shape=box]; A; w; h; p;
    node [shape=circle,fixedsize=true,width=0.2,label=""]; 
    A2wh [color=lightgray]; wh2A; ph2w [color=lightgray]; pw2h; wh2p [color=lightgray];

   { rank=same; A }
   { rank=same; A2wh; wh2A }
   { rank=same; w; h }
   { rank=same; ph2w; pw2h }
   { rank=same; wh2p }
   { rank=same; p }

    A -> A2wh [color=lightgrey];
    A2wh -> {w h} [color=lightgrey];

    w -> wh2A; 
    h -> wh2A; 
    wh2A -> A;

    w -> wh2p [color=lightgrey];
    h -> wh2p [color=lightgrey];
    wh2p -> p [color=lightgrey];

    p -> pw2h [constraint=false];
    w -> pw2h;
    pw2h -> h [constraint=false];

    edge [color=lightgrey];
    p -> ph2w [constraint=false];
    h -> ph2w;
    ph2w -> w [constraint=false];

    overlap=false
    fontsize=12;
  }
#+end_src

#+NAME: awh-flow-3
#+begin_src dot :file area-w-h-perimeter-flow-3.png :cmd neato :cmdline -Kdot -Tpng :results none
  digraph whap {
    size="3,2";
    rankdir=LR; ranksep=1;
    node [shape=box]; A; w; h; p;
    node [shape=circle,fixedsize=true,width=0.2,label=""]; 
    A2wh [color=lightgray]; wh2A; ph2w [color=lightgray]; pw2h [color=lightgray]; wh2p;

   { rank=same; A }
   { rank=same; A2wh; wh2A }
   { rank=same; w; h }
   { rank=same; ph2w; pw2h }
   { rank=same; wh2p }
   { rank=same; p }

    A -> A2wh [color=lightgrey];
    A2wh -> {w h} [color=lightgrey];

    w -> wh2A; 
    h -> wh2A; 
    wh2A -> A;

    w -> wh2p;
    h -> wh2p;
    wh2p -> p;

    edge [color=lightgrey];
    p -> pw2h [constraint=false];
    w -> pw2h;
    pw2h -> h [constraint=false];

    p -> ph2w [constraint=false];
    h -> ph2w;
    ph2w -> w [constraint=false];

    overlap=false
    fontsize=12;
  }
#+end_src

#+NAME: awh-flow-4
#+begin_src dot :file area-w-h-perimeter-flow-4.png :cmd neato :cmdline -Kdot -Tpng :results none
  digraph whap {
    size="3,2";
    rankdir=LR; ranksep=1;
    node [shape=box]; A; w; h; p;
    node [shape=circle,fixedsize=true,width=0.2,label=""]; 
    A2wh [color=lightgray]; wh2A; ph2w; pw2h [color=lightgray]; wh2p [color=lightgray];

   { rank=same; A }
   { rank=same; A2wh; wh2A }
   { rank=same; w; h }
   { rank=same; ph2w; pw2h }
   { rank=same; wh2p }
   { rank=same; p }

    A -> A2wh [color=lightgrey];
    A2wh -> {w h} [color=lightgrey];

    w -> wh2A; 
    h -> wh2A; 
    wh2A -> A;

    edge [color=lightgrey];
    w -> wh2p;
    h -> wh2p;
    wh2p -> p;

    p -> pw2h [constraint=false];
    w -> pw2h;
    pw2h -> h [constraint=false];

    edge [color=black];
    p -> ph2w [constraint=false];
    h -> ph2w;
    ph2w -> w [constraint=false];

    overlap=false
    fontsize=12;
  }
#+end_src

# Results collected here manually to be able to place images inline

#+CAPTION: The dataflows of the /whap/ constraint system.
#+LABEL: fig:whap-dataflows
#+ATTR_HTML: :rules none :frame void :style margin-left:auto; margin-right:auto;
| [[file:area-w-h-perimeter-flow-1.png]] | [[file:area-w-h-perimeter-flow-2.png]] |
| [[file:area-w-h-perimeter-flow-3.png]] | [[file:area-w-h-perimeter-flow-4.png]] |


[fn:1] The decomposition can be arbitrary, except that the output variables of one method cannot be
a subset of those of another method.

# ** Commands

# /Commands/ are procedures that observe and modify
# the variable values in HotDrink's constraint system. After
# executing each command, HotDrink solves the constraint system. Both
# commands and methods can be asynchronous. HotDrink coordinates their
# execution so that consistency is preserved.

** Architecture of a HotDrink GUI 

Applications written with HotDrink can be viewed as instances the
/Model-View-ViewModel/ (a.k.a. MVVM) design pattern.  This pattern
divides the application as follows:

- The /View/ is responsible for presentation and capturing
  interactions with the user.

- The /ViewModel/ is manages the data presented in the view.  HotDrink
  maintains the view-model as a constraint system.

- The /bindings/ connect elements in the view with variables in the
  view-model. They (1) user events in the view and generate
  requests to change the constraint system's variables, and (2) deliver
  new variable values to the vies after constraints have been solved.

- The /Model/ is responsible for the ``business-logic''.  It is
  usually not aware of the user interface, and it is not discussed
  in this tutorial.

* A Simple HotDrink Application

This section shows the implementation of the /whap/ GUI above.
Playing with the GUI quickly reveals that it is rather rudimentary:
fields allow negative lengths, non-numeric input is not filtered out,
etc. In the interest of keeping the discussion foucsed on HotDrink, we
accept these shortcomings for now.

** Importing HotDrink 

To use HotDrink on a page, import the [[file:hotdrink.min.js][=hotdrink.min.js=]] script (that
came with this tutorial).  Concretely, add the following to the
~<head>~ section of your HTML, with the appropriate path in the ~src~
attribute.

#+BEGIN_SRC html
<script type="text/javascript" src="hotdrink.min.js"></script>
#+END_SRC

To avoid conflicts with other libraries, HotDrink exports only one
global symbol, ~hd~, and all of its interactions with the DOM are via
cooperative API functions, such as [[https://developer.mozilla.org/en-US/docs/Web/API/EventTarget.addEventListener][~addEventListener~]].

** Primary HotDrink objects

There are three primary object types that appear in a ``HotDrinked'' application.

1. A ~PropertyModel~ object represents the view-model.  It manages a
   constraint system. In the simplest case, an application has a
   single property model that, in its variables, maintains all data
   relevant for the view.  

2. A ~Component~ object is a collection of property model elements:
   variables, constraints, commands, and components.  Components are
   merely a grouping mechanism that allow several elements to be
   adding to or removed from a property model in one operation.

3. A ~ComponentBuilder~ object with its member functions is a language
   for constructing components.  By chaining method calls of a
   ~ComponentBuilder~ object the programmer defines a component's
   elements.  The constraint system specification in the
   {{{scraplink(whap-component)}}} source block is written using the
   component builder's language.

** The View 

HotDrink does not dictate how the View of an application 
is implemented; we use HTML here.

#+CAPTION: whap-view
#+BEGIN_SRC html -n -r :exports code :tangle tangle/intro.html :padline no :noweb strip-export
<<whap-css>>
  <fieldset id="whap-gui">
    <label for="A">A</label><input id="A" type="text"></input>

    <span class="vertical-middle">
      <label for="w">w</label><input id="w"  type="text"/></br>
      <label for="h">h</label><input id="h" type="text"/>
    </span>

    <label for="p">p</label><input id="p" type="text"/>
  </fieldset>
#+END_SRC

Adding some styling lines the labels and textboxes nicely.

#+CAPTION: whap-css
#+NAME: whap-css
#+BEGIN_SRC html -n -r :exports code 
  <style type="text/css">
    fieldset#whap-gui input[type="text"] { width: 8ex; margin-right: 2ex }
    fieldset#whap-gui label { display:inline-block; width: 1.5ex; } 
    .vertical-middle { display:inline-block; vertical-align:middle; } 
  </style>
#+END_SRC

** ViewModel

The view-model is a ~PropertyModel~ object. It keeps any constraints
that are added to it enforced. A property model accepts constraints as
grouped into components. The code below adds the ~whap~ component
(that was defined in the {{{scraplink(whap-component)}}} block) to the
property model ~pm~.

#+NAME: construct-property-model
#+BEGIN_SRC js :noweb yes
var pm = new hd.PropertyModel();
pm.addComponent(whap);
#+END_SRC

The property model ~pm~ now manages the view-model's state.  The
adding of ~whap~ triggers the solver, which enforces the constraints
$A = w h$ and $p = w + h$ are enforced. They remain enforced, as
nothing yet modifies the property model's variables.

** Writing to and Reading from Variables

First, the property model object offers no API for accessing
components that have been added to it. The access to a variables is
through the component that contains it. For example, the $w$ variable
is accessed as ~whap.w~.

The ~set~ method writes a new value to a variable.
There is a ~get~ method too, but it is usually not what
should be used to read a variable's value. To see why,
we analyze the ~set~ call in details.

Consider the call ~whap.w.set(9)~. After this call, the property
model's constraint system is solved.  This will causing some
variable's value to change, including ~w~'s.  These changes are not,
however, immediate; when ~set~ returns, no variable has changed its
value yet.  As a concrete example, the code below writes some prior
value of ~w~ on the console, not ~9~.

#+BEGIN_SRC js
whap.w.set(9); 
console.log(whap.w.get());
#+END_SRC

What ~set~ does do immediately, is to create a /promise/ for each
variable whose value will change as a result of solving the constraint
system. This promise's /eventual value/ will be written to the
variable. Rewriting the above example as below will print ~9~.

#+BEGIN_SRC js
whap.w.set(9); 
whap.w.getStagedPromise().then(v => console.log(v));
#+END_SRC

The ~getStagedPromise~ function is not the typical way of reading
variables' values either; its use here was to explain what goes on in
the property model after a ~set~.  Instead, the typical mechanism of
obtaining a variable's value is by registering an /observer/ object on
a variable.  Property model's variables are /observables/ that accept
such registrations.

A variable's observers can define three callback
members: ~onNext(v)~ to be called whenever the variable receives a new
value ~v~, ~onError(e)~ if it receives an error value ~e~, and
~onCompleted()~ when no new values will be received anymore.

We write the above example once more, now using an observer:

#+BEGIN_SRC js
whap.w.addObserver({onNext: v => console.log(v)});
whap.w.set(9); 
#+END_SRC

** Bindings --- Connecting the View and the ViewModel

Bindings observe changes in the view, changes in the view-model, or
both. HotDrink offers many convenient ways for defining and
registering observers, but below we show the mechanism in its basic
form.

We first define the function ~textBinder~ that takes two parameters, a
DOM element (a textbox) ~box~ and a variable ~v~ in a property model,
and binds them so that a change in either will be reflected in the
other. The function thus creates a /two-way/ binding. 

#+NAME: simple-two-way-textbox-binder
#+BEGIN_SRC js
  function textBinder(box, v) {
    v.addObserver({ onNext: val => { box.value = val } });
    box.addEventListener('input', () => { v.set(box.value); });
  };
#+END_SRC

The observing of changes in ~v~ is accomplished by adding an
observable object to ~v~. The change is reflected in the DOM object
~box~ by assigning to ~box.value~. This simple observable defines only
the ~onNext~ method, ignoring any error and completion messages.
The observing of changes in the DOM object's value is accomplished
by registering a handler to ~box~'s ~input~ event. 
The handler calls ~set~ to assign a new value for ~v~.

Calling ~textBinder~ with all four textbox-variable pairs
creates the desired connections.

#+CAPTION: create-four-binders
#+NAME: create-four-binders
#+BEGIN_SRC js
  textBinder(document.getElementById("A"), whap.A);
  textBinder(document.getElementById("w"), whap.w);
  textBinder(document.getElementById("h"), whap.h);
  textBinder(document.getElementById("p"), whap.p);
#+END_SRC


To point out an obvious issue, the calls to ~textBinder~
should only be issued after the DOM is available.

#+NAME: on-load
#+BEGIN_SRC js -n -r :exports code :padline no :noweb tangle
  window.addEventListener( 'load', function() {
    <<create-four-binders>>
  } );
#+END_SRC


#+BEGIN_SRC js -n -r :exports none :padline no :noweb yes :tangle tangle/intro.js
// Define a constraint system (variables and constraints) as a component
<<whap-component>>

// Define the property model and add its components
<<construct-property-model>>

<<simple-two-way-textbox-binder>>

<<on-load>>
#+END_SRC

** Commands

MUST WRITE THIS SECTION

# In many ways, a command is similar to an event handler.  However, whereas an
# event handler represents something that happened in the View, a command
# represents something that happened in the View-Model.  For example, a
# key-press event is generated when the user presses a key.  That event is
# translated by a binding into a variable-set command.

# Most commands in this example are, in fact, variable-set commands issued by
# bindings.  These commands are created automatically; no extra work is
# required.  If you want to create your own custom commands, however, you may do
# so using the component builder.

# #+NAME: command
# #+BEGIN_SRC js
#     // Create a custom command named 'dimensions'
#     .command( 'dimensions', '!w, !h -> w, h', function(w, h) {
#       alert( "The dimensions are " + w + " " + h);
#       var wh = (w+h)/2;
#       return [wh, wh];
#     })
# #+END_SRC

# This command can be bound to events, like button presses.  Commands can also
# be used to modify variables of the property model, or event modify the
# property model itself, adding or removing variables, constraints, etc.

#  LocalWords:  HotDrink javascript src js stylesheet css href INFOJS sdepth
#  LocalWords:  le HotDrink's multi ldquo rdquo MVVM ViewModel html JQuery hd
#  LocalWords:  Dojo MooTools DOM API addEventListener padline noweb th td
#  LocalWords:  checkin oneDayMs setHours ComponentBuilder propmod num getTime
#  LocalWords:  ModelBuilder PropertyModel addComponent removeComponent
#  LocalWords:  performDeclaredBindings


# Changes to GUI state are managed through /commands/ written by the programmer.
# HotDrink ensures that (1) commands are initiated only when all relationships
# defined by the programmer have been enforced, and (2) commands will not
# interfere with one another, at least with respect to the GUI state.  This
# means that your program will behave correctly even if a new command is issued
# before the previous command has finished.

* File local variables                                     :noexport:
  
# Local Variables:
# mode: org
# org-html-postamble: nil
# org-babel-use-quick-and-dirty-noweb-expansion: t
# org-confirm-babel-evaluate: nil
# End:
