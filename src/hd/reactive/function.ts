/*####################################################################
 * Lifting function over values to function over promises.
 */
module hd.reactive {

  import u = hd.utility;
  import r = hd.reactive;

  /*==================================================================
   * The actual lifting function.
   */
  export function liftFunction( fn: Function,
                                mask: boolean[] = null  ) {
    return function( ...parameters: Promise<any>[] ) {
      var invocation = new LiftedFunctionInvocation( fn, parameters, mask );
      return invocation.output;
    }
  }

  // unique value used to indicate that the corresponding promise has
  //   never produced a value (including progress notifications)
  var noValue = {};

  /*==================================================================
   * A lifted function invocation.
   */
  class LiftedFunctionInvocation {

    // The inputs given to the function
    private inputs: u.MultiArray<any>;

    // List of promises we have subscribed to
    private promises: r.Promise<any>[] = [];

    // The params generated by resolving all promises in inputs
    private params: u.MultiArray<any>;

    // How many promises are currently pending
    private pending = 0;

    // How many promises have never produced a value (pending + !progress)
    private noValue = 0;

    // The function to lift
    private fn: Function;

    // The output of the function
    output = new r.Promise<any>();

    /*----------------------------------------------------------------
     * Subscribe to all input promises
     */
    constructor( fn: Function, inputs: u.MultiArray<any>, mask: u.MultiArray<boolean> = null ) {
      this.fn = fn;
      this.inputs = inputs;
      this.params = this.genParams( inputs, mask, [] );
      this.output.ondropped.addObserver( this );

      if (this.pending == 0) {
        this.invoke();
      }
    }

    /*----------------------------------------------------------------
     * Convert input array to parameter array -- i.e., replacing
     * promises with their value.
     */
    private
    genParams(
      inputs: u.MultiArray<any>,
      mask:   u.MultiArray<boolean>,
      place:  number[]
    ):        u.MultiArray<any> {

      var params: any[] = [];
      for (var i = 0, l = inputs.length; i < l; ++i) {
        var input = inputs[i];

        if (Array.isArray( input )) {
          params[i] = this.genParams( input,
                                      Array.isArray( mask ) ? <u.MultiArray<boolean>>mask[i] : null,
                                      place.concat( [i] ) );
        }
        else if (input instanceof r.Promise) {
          if (Array.isArray( mask ) && mask[i]) {
            params[i] = input;
          }
          else {
            params[i] = noValue;
            input.addDependency(
              this,
              this.onParamFulfilled,
              this.onParamRejected,
              this.onParamProgress,
              place.concat( [i] )
            );
            this.promises.push( input );
            ++this.pending;
            ++this.noValue;
          }
        }
        else {
          params[i] = input;
        }
      }
      return params;
    }

    /*----------------------------------------------------------------
     * Inserts the value of a resolved promise into the parameter
     * multi-array.
     */
    private
    resolveParam(
      value: any,
      params: u.MultiArray<any>,
      place: number[],
      i: number
    ) {

      var idx = place[i];
      if (i == place.length - 1) {
        if (params[idx] === noValue) {
          --this.noValue;
        }
        params[idx] = value;
      }
      else {
        this.resolveParam( value, params[idx], place, i + 1 );
      }
    }

    /*----------------------------------------------------------------
     * Called when promise resolves
     */
    onParamFulfilled( value: any, place: number[] ) {
      this.resolveParam( value, this.params, place, 0 );
      --this.pending;
      if (this.noValue == 0) {
        this.invoke();
      }
    }

    /*----------------------------------------------------------------
     * If any parameter fails then we fail
     */
    onParamRejected( reason: any ) {
      this.output.reject( null );
      this.promises.forEach( function( p: Promise<any> ) {
        p.removeDependency( this );
      }, this );
    }

    /*----------------------------------------------------------------
     * Set the corresponding value; notify
     */
    onParamProgress( value: any, place: number[] ) {
      this.resolveParam( value, this.params, place, 0 );
      if (this.noValue == 0) {
        this.invoke();
      }
    }

    /*----------------------------------------------------------------
     */
    private
    invoke() {
      try {
        var result = this.fn.apply( null, this.params );
        if (this.pending == 0) {
          this.output.resolve( result );
        }
        else {
          this.output.notify( result );
        }
      }
      catch (e) {
        console.error( e );
        this.output.reject( e );
      }
    }

    /*----------------------------------------------------------------
     */
    onNext( p: r.Promise<any> ) {
      if (p === this.output) {
        this.promises.forEach( function( p: Promise<any> ) {
          p.removeDependency( this );
        }, this );
      }
    }

    onError() { }
    onCompleted() { }

  }

}
